<!-- Good morning, Mr. Phelps. -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>or-tools/graph/: operations_research Namespace Reference - Doxy</title>
    <link rel="shortcut icon" href="../../favicon.ico">
    <!-- Both stylesheets are supplied by Doxygen, with maybe minor tweaks from Google. -->
    <link href="../../doxygen.css" rel="stylesheet" type="text/css">
    <link href="../../tabs.css" rel="stylesheet" type="text/css">
  </head>

  <body topmargin=0 leftmargin=20 bottommargin=0 rightmargin=20 marginwidth=20 marginheight=0>
  <!-- Second part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
  <style>
    a.doxy_logo:hover {
      background-color: #389613
    }
  </style>

  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <!-- Top horizontal line with the color of the day. -->
    <tr valign=top>
      <td colspan=3 bgcolor=#389613 height=3></td>
    </tr>

    <!-- Header row with the links at the right. -->
    <tr valign=top>
      <td colspan=3 align=right>
        <font size=-1>
          Generated on: <font color=#389613><b>Fri Apr  1 14:13:18 PDT 2011</b></font>
            for <b>custom file set</b>
        </font>
      </td>
    </tr>

    <!-- Header row with the logo and the search form. -->
    <tr valign=top>
      <!-- Logo. -->
      <td align=left width=150>
        <table width=150 height=54 cellpadding=0 cellspacing=0 border=0>
          <tr valign=top>
            <!-- First part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
            <td bgcolor=#389613>
              <a class="doxy_logo" href="../../index.html"><img src="../../doxy_logo.png" alt="Doxy" border=0></a>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <!-- Tiny vertical space below the form. -->
    <tr valign=top>
      <td colspan=3 height=3></td>
    </tr>
  </table>

  <!-- Header navigation row. -->
  <div class="memproto">
    <table width=100% cellpadding=0 cellspacing=0 border=0>
      <tr>
        <td align=left style="padding-left: 20px"><font size=+1><b><tt><font color=#333333>//
            <a href="../../index.html"><font color=#389613>doxy</font></a>/</font>
            <a href="../../or-tools/index.html">or-tools</a>/
            <a href="../../or-tools/graph/index.html">graph</a>/
            </tt></b></font>
        </td>
      </tr>
    </table>
  </div>
  <br />
    <!-- No subdirs found. -->
  <!-- End of header. -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>operations_research Namespace Reference</h1>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BellmanFord.html">BellmanFord</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConnectedComponents.html">ConnectedComponents</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template class implementing a Union-Find algorithm with path compression for maintaining the connected components of a graph.  <a href="classoperations__research_1_1ConnectedComponents.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DijkstraSP.html">DijkstraSP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">namespace  <a href="classoperations__research_1_1DijkstraSP.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MaxFlow.html">MaxFlow</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MinCostFlow.html">MinCostFlow</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1anonymous__namespace_02bron__kerbosch_8cc_03.html">anonymous_namespace{bron_kerbosch.cc}</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1anonymous__namespace_02dijkstra_8cc_03.html">anonymous_namespace{dijkstra.cc}</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#bd22b9920b8b8f150cc9263533cebe1b">NodeIndex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#6f44eda801f15f3cd9de08a5860bb5d6">ArcIndex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#5841ff601ab08548afb15c45b2245de7">FlowQuantity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7950685633ee869aa9471b2ec5fbcfa">CostValue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a><br>
&lt; <a class="el" href="namespaceoperations__research.html#95c8c3167a0caffc6f615bc28f674ff2">kStarGraphNodeIndexSize</a>, <br>
<a class="el" href="namespaceoperations__research.html#6fe2703e317fb0eaa16d155ae7a6ddba">kStarGraphArcIndexSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ed5bb564de2974655b4759919bdadc10">StarGraph</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PackedArray<br>
&lt; <a class="el" href="namespaceoperations__research.html#95c8c3167a0caffc6f615bc28f674ff2">kStarGraphNodeIndexSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#416534efbfb6234f89dd9f9053e9232a">NodeIndexArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PackedArray<br>
&lt; <a class="el" href="namespaceoperations__research.html#6fe2703e317fb0eaa16d155ae7a6ddba">kStarGraphArcIndexSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#fb1f6bf36479d8f859d80a984fb2e391">ArcIndexArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#09767b3634289e432c3ce1d7c649666a">PathNodeIndex</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#891a1aa6cd60571a0d3a82c70c9de3c2">BellmanFordShortestPath</a> (int node_count, int start_node, int end_node, ResultCallback2&lt; int64, int, int &gt; *const graph, vector&lt; int &gt; *nodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bellman-Ford Shortest path with callback-based description of the graph.  <a href="#891a1aa6cd60571a0d3a82c70c9de3c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#03b2245563a4dc4d5dad9659ff992109">FindCliques</a> (ResultCallback2&lt; bool, int, int &gt; *const graph, int node_count, ResultCallback1&lt; bool, const vector&lt; int &gt; &amp; &gt; *const callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">namespace  <a href="#03b2245563a4dc4d5dad9659ff992109"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#e06e3ebda956e99a0771ad662d657ff3">CoverArcsByCliques</a> (ResultCallback2&lt; bool, int, int &gt; *const graph, int node_count, ResultCallback1&lt; bool, const vector&lt; int &gt; &amp; &gt; *const callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will cover the maximum number of arcs of the graph with cliques.  <a href="#e06e3ebda956e99a0771ad662d657ff3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#57679b4c15d8ddb5fe920952969685af">DijkstraShortestPath</a> (int node_count, int start_node, int end_node, ResultCallback2&lt; int64, int, int &gt; *const graph, vector&lt; int &gt; *nodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dijsktra Shortest path with callback based description of the graph.  <a href="#57679b4c15d8ddb5fe920952969685af"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#95c8c3167a0caffc6f615bc28f674ff2">kStarGraphNodeIndexSize</a> = 5</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard definition of the star representation of a graph, that makes it possible to address all the physical memory on a 2010 machine, while keeping the sizes of arcs and nodes reasonable.  <a href="#95c8c3167a0caffc6f615bc28f674ff2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#6fe2703e317fb0eaa16d155ae7a6ddba">kStarGraphArcIndexSize</a> = 5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#28fc2443c096ea8754eaa40697e4fc94">kHamiltonianPathSolverPadValue</a> = 1557</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. 
<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Graph connectivity algorithm for undirected graphs. Memory consumption: O(n) where m is the number of arcs and n the number of nodes. <dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>): add depth-first-search based connectivity for directed graphs. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>): add depth-first-search based biconnectivity for directed graphs. </dd></dl>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation (with some improvements) of the star-representation of a graph as described in J. Ebert, "A versatile data structure for arc-oriented graph algorithms." Communications of the ACM 30(6):513-519 (June 1987). Both forward- and backward-star representations are contained in this representation. The graph is represented with three arrays. Let n be the number of nodes and m be the number of arcs. Let i be an integer in [1..m], denoting the index of an arc. node_[i] contains the end-node of arc i, node_[-i] contains the start-node of arc i. Consequently: node_[-i] contains the start-node of the arc reverse to arc i, node_[i] contains the end-node of the arc reverse to arc i. Note that if arc (u,v) is defined, then the data structure also stores (v, u). Arc -i thus denotes the arc reverse to arc i. This is what makes this representation useful for undirected graphs, and for implementing algorithms like two-directions shortest-path.<p>
Now, for an integer u in [1..n] denoting the index of a node: first_incident_arc_[u] denotes the first arc in the adjacency list of u. going from an arc i, the adjacency list can be traversed using j = next_adjacent_arc_[i].<p>
Note that arc index 0 is not used (because negative indices denote reverse arcs.) Therefore care must be taken about the fact that arc indices (and for consistency, node indices) start at 1.<p>
This implementation has the following benefits: It is able to handle both directed or undirected graphs. Being based on indices, it is easily serializable. Only the contents of the node_ array needs to be stored. The sizes of node indices and arc indices can be specified in number of bytes. For example, it is possible to store indices on 5 bytes or 40 bits, which seems like a good compromise for the architectures of 2010. This represents a 37.5% savings compared to a pointer-based implementation. Taking into account the fact that no extra pointer to the reverse arc is needed, only 80 bits are needed to store an arc instead of 192 bits if a pointer-based representation were used. The representation can be recomputed if edges have been loaded from external memory or if edges have been re-ordered. The memory consumption is: (2 * m + 1) * NodeIndexSize + (2 * m + 1) * ArcIndexSize + (n + 1) * ArcIndexSize<p>
The main drawback of this implementation is that the node and arc indices start at 1 instead of the usual 0 in C/C++.<p>
This implementation differs from the implementation described in [Ebert 1987] in the following respects: it is possible to add arcs to the graph, with AddArc, in a much simpler way than described by Ebert. <dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>) it is possible to group all the outgoing (resp. incoming) arcs of a node to allow to traverse the outgoing (resp. incoming) arcs in O(out_degree(node)) (resp. O(in_degree(node))) instead of O(degree(node)). </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>) it is possible to implement arc deletion and garbage collection in an efficient (relatively) manner. For the time being we haven't seen an application to this. </dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>) implement "interleaved" version of this, with direct arcs having even indices (2*i), and reverse arcs having odd indices (2*i+1). As suggested by lhm this could have better cache properties. This has to be validated on algorithms running with real data. </dd></dl>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Solves the Shortest Hamiltonian Path Problem using a complete algorithm. The algorithm was first described in M. Held, R.M. Karp, A dynamic programming approach to sequencing problems, J. SIAM 10 (1962) 196–210<p>
The Shortest Hamiltonian Path Problem (SHPP) is similar to the Traveling Salesperson Problem (TSP). You have to visit all the cities, starting from a given one and you do not need to return to your starting point. With the TSP, you can start anywhere, but you have to return to your start location.<p>
By complete we mean that the algorithm guarantees to compute the optimal solution. The algorithm uses dynamic programming. Its time complexity is O(n*2^n), where n is the number of nodes to be visited. Its space complexity is also O(n*2^n).<p>
Note that the naive implementation of the SHPP exploring all permutations without memorizing intermediate results would have a complexity of (n-1)! (factorial of (n-1) ), which is much higher than n*2^n. To convince oneself of this, just use Stirling's formula: n! ~ sqrt(2*pi*n)*(n/exp(1))^n . Because of these complexity figures, the algorithm is not practical for problems with more than 20 nodes.<p>
Here is how the algorithm works: Let us denote the nodes to be visited by their indices 0..n-1 Let us pick 0 as the starting node. Let d(i,j) denote the distance (or cost) from i to j. f(S,j) where S is a set of nodes and j is a node is defined as follows: f(S,j) = min(i in S, f(Si}, i) + d(i,j))<p>
The set S can be represented by an integer where bit i corresponds to element i in the set. In the following S denotes the integer corresponding to set S.<p>
The computation of f(S,j) is implemented in the method ComputeShortestPath.<p>
To implement dynamic programming, we store the preceding results of computing f(S,i) in an array M[S][i]. Since there are 2^n subsets of the set {0..n-1}, there are 2^n rows and n columns in this array. This explains the complexity figures.<p>
The array M is initialized as follows: for i in (0..n-1) M[0][i] = d(0,i) The dynamic programming iteration is as follows: for S in (0..2^n-2) for i in (0..n-1) M[S][i]=f(S,i)<p>
The dynamic programming iteration is implemented in the method Solve. The optimal value of the Hamiltonian path from 0 to n-1 is given by f(2^n-1,n-1). The optimal value of the Traveling Salesman tour is given by f(2^n-1,0). (There is actually no need to duplicate the first node.)<p>
There are a few tricks in the efficient implementation of this algorithm which are explained below.<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a push-relabel algorithm for the max flow problem.<p>
In the following, we consider a graph G = (V,E,s,t) where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges). s and t denote distinguished nodes in G called source and target. n = |V| denotes the number of nodes in the graph, and m = |E| denotes the number of arcs in the graph.<p>
Each arc (v,w) is associated a capacity c(v,w). A flow is a function from E to R such that: a) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint.) b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint.) c) sum on v f(v,w) = 0 (flow conservation.)<p>
The goal of this algorithm is to find the maximum flow from s to t, i.e. for example to maximize sum v f(s,v).<p>
The starting reference for this class of algorithms is: A.V. Goldberg and R.E. Tarjan. A new approach to the maximum flow problem. ACM Symposium on Theory of Computing, pp. 136-146. <a href="http://portal.acm.org/citation.cfm?id=12144">http://portal.acm.org/citation.cfm?id=12144</a><p>
The basic idea of the algorithm is to handle preflows instead of flows, and to refine preflows until a maximum flow is obtained. A preflow is like a flow, except that the inflow can be larger than the outflow. If it is the case at a given node v, it is said that there is an excess at node v, and inflow = outflow + excess. More formally, a preflow is a function f such that: 1) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint). c(v,w) is a value representing the maximum capacity for arc (v,w). 2) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint) 3) excess(v) = sum on u f(u,v) &gt;= 0 is the excess at node v, the algebraic sum of all the incoming preflows at this node.<p>
Each node has an associated "height", in addition to its excess. The height of the source is defined to be equal to n, and cannot change. The height of the target is defined to be zero, and cannot change either. The height of all the other nodes is initialized at zero and is updated during the algorithm (see below). For those who want to know the details, the height of a node, corresponds to a reduced cost, and this enables one to prove that the algorithm actually computes the max flow. Note that the height of a node can be initialized to the to the target node in terms of number of nodes. This has not been tried in this implementation.<p>
A node v is said to be *active* if excess(v) &gt; 0. In this case the following operations can be applied to it:<ul>
<li>if there are *admissible* incident arcs, i.e. arcs which are not saturated, and whose tail's height is lower than the height of the active node considered, a PushFlow operation can be applied. It consists in sending as much flow as both the excess at the node and the capacity of the arc permit.</li><li>if there are no admissible arcs, the active node considered is relabeled, i.e. its height is increased to 1 + the minimum height of its neighboring nodes on admissible arcs. This is implemented in Optimize, which itself calls PushFlow and Relabel.</li></ul>
<p>
Before running Optimize, it is necessary to initialize the algorithm with a preflow. This is done in InitializePreflow, which saturates all the arcs leaving the source node, and sets the excess at the heads of those arcs accordingly.<p>
The algorithm terminates when there are no remaining active nodes, i.e. all the excesses at all nodes are equal to zero. In this case, a maximum flow is obtained.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>): implement the following active node choice rule.</dd></dl>
The complexity of this algorithm depends amongst other things on the choice of the next active node. It has been shown, for example in: L. Tuncel, "On the Complexity of Preflow-Push Algorithms for Maximum-Flow Problems", Algorithmica 11(4): 353-359 (1994). and J. Cheriyan and K. Mehlhorn, "An analysis of the highest-level selection rule in the preflow-push max-flow algorithm", Information processing letters, 69(5):239-242 (1999). <a href="http://www.math.uwaterloo.ca/~jcheriya/PS_files/me3.0.ps">http://www.math.uwaterloo.ca/~jcheriya/PS_files/me3.0.ps</a><p>
that choosing the active node with the highest level yields a complexity of O(n^2 * sqrt(m)).<p>
This has been validated experimentally in: R.K. Ahuja, M. Kodialam, A.K. Mishra, and J.B. Orlin, "Computational Investigations of Maximum Flow Algorithms", EJOR 97:509-542(1997). <a href="http://jorlin.scripts.mit.edu/docs/publications/">http://jorlin.scripts.mit.edu/docs/publications/</a> 58-comput20investigations20of.pdf<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow Problem.” In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008. www.springerlink.com/index/5535k2j1mt646338.pdf </dd></dl>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a cost-scaling push-relabel algorithm for the min-cost flow problem.<p>
In the following, we consider a graph G = (V,E) where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges). n = |V| denotes the number of nodes in the graph, and m = |E| denotes the number of arcs in the graph.<p>
To each arc (v,w) is associated a capacity c(v,w) and a unit cost cost(v,w). To each node v is associated quantity named supply(v), which represents a supply of fluid (if &gt;0) or a demand (if &lt;0). Furthermore, no fluid are created in the graph so sum on v in V supply(v) = 0<p>
A flow is a function from E to R such that: a) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint). b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint). c) sum on v f(v,w) = 0 (flow conservation.<p>
The cost of a flow is sum on (v,w) in E ( f(v,w) * cost(v,w) )<p>
The problem to solve is to find a flow of minimum cost such that all the fluid flows from the supply nodes to the demand nodes.<p>
The principles behind this algorithm are the following: 1/ handle pseudo-flows instead of flows and refine pseudo-flows until an epsilon-optimal minimum-cost flow is obtained, 2/ deal with epsilon-optimal pseudo-flows.<p>
1/ A pseudo-flow is like a flow, except that the inflow can be different from the outflow. If it is the case at a given node v, it is said that there is an excess (or deficit) at node v. A deficit is denoted by a negative excess and inflow = outflow + excess. (Look at <a class="el" href="max__flow_8h.html">graph/max_flow.h</a> to see that the definition of preflow is more restrictive than the one for pseudo-flow in that a preflow only allows non-negative excesses, i.e. no deficit.) More formally, a pseudo-flow is a function f such that: a) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint). b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint).<p>
For each v in E, we also define the excess at node v, the algebraic sum of all the incoming preflows at this node, added together with the supply at v. excess(v) = sum on u f(u,v) + supply(v)<p>
The goal of the algorithm is to obtain excess(v) = 0 for all v in V, while consuming capacity on some arcs, at the lowest possible cost.<p>
2/ Each node has an associated "price" (or potential), in addition to its excess. It is formally a function from E to R (the set of real numbers.). For a given price function p, the reduced cost of an arc (v,w) is: cost_p(v,w) = cost(v,w) + p(v) - p(w) (cost(v,w) is the cost of arc (v,w) .)<p>
For a constant epsilon &gt;= 0, a pseudo-flow f is said to be epsilon-optimal with respect to a pricing function p if for all residual arc (v,w) in E, cost_p(v,w) &gt;= -epsilon.<p>
A flow f is optimal if and only if there exists a price function p such that no arc is admissible with respect to f and p.<p>
If the arc costs are integers, and epsilon &lt; 1/n, any epsilon-optimal flow is optimal. The integer cost case is handled by multiplying all the arc costs and the initial value of epsilon by (n+1). When epsilon reaches 1, and the solution is epsilon-optimal, it means: for all residual arc (v,w) in E, (n+1) * cost_p(v,w) &gt;= -1, thus cost_p(v,w) &gt;= -1/(n+1) &gt;= 1/n, and the solution is optimal.<p>
A node v is said to be *active* if excess(v) &gt; 0. In this case the following operations can be applied to it:<ul>
<li>if there are *admissible* incident arcs, i.e. arcs which are not saturated, and whose reduced costs are negative, a PushFlow operation can be applied. It consists in sending as much flow as both the excess at the node and the capacity of the arc permit.</li><li>if there are no admissible arcs, the active node considered is relabeled, This is implemented in Discharge, which itself calls PushFlow and Relabel.</li></ul>
<p>
Discharge itself is called by Refine. Refine first saturates all the admissible arcs, then builds a stack of active nodes. It then applies Discharge for each active node, possibly adding new ones in the process, until no nodes are active. In that case an epsilon-optimal flow is obtained.<p>
Optimize iteratively calls Refine, while epsilon &gt; 1, and divides epsilon by alpha (set by default to 5) before each iteration.<p>
The algorithm starts with epsilon = C, where C is the maximum absolute value of the arc costs. In the integer case which we are dealing with, since all costs are multiplied by (n+1), the initial value of epsilon is (n+1)*C. The algorithm terminates when epsilon = 1, and Refine() has been called. In this case, a minimum-cost flow is obtained.<p>
The complexity of the algorithm is O(n^2*m*log(n*C)) where C is the value of the largest arc cost in the graph.<p>
The starting reference for this class of algorithms is: A.V. Goldberg and R.E. Tarjan, "Solving Minimum-Cost Flow Problems by Successive Approximation." Proceedings of ACM STOC'87, 1987:7-18. <a href="http://portal.acm.org/citation.cfm?id=28397&CFID=10541307&CFTOKEN=40586317">http://portal.acm.org/citation.cfm?id=28397&amp;CFID=10541307&amp;CFTOKEN=40586317</a><p>
Implementation issues are tackled in: A.V. Goldberg, "An Efficient Implementation of a Scaling Minimum-Cost Flow Algorithm," Journal of Algorithms, (1997) 22:1-29 <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.258">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.258</a><p>
A.V. Goldberg and M. Kharitonov, "On Implementing Scaling Push-Relabel Algorithms for the Minimum-Cost Flow Problem", Network flows and matching: First DIMACS implementation challenge, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, (1993) 12:157-198. <a href="ftp://dimacs.rutgers.edu/pub/netflow/...mincost/scalmin.ps">ftp://dimacs.rutgers.edu/pub/netflow/...mincost/scalmin.ps</a> and in: ﻿U. Bunnagel, B. Korte, and J. Vygen. “Efficient implementation of the Goldberg-Tarjan minimum-cost flow algorithm.” Optimization Methods and Software (1998) vol. 10, no. 2:157-174. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.9897">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.9897</a><p>
We have tried as much as possible in this implementation to keep the notations and namings of the papers cited above, except for 'demand' or 'balance' which have been replaced by 'supply', with the according sign changes to better accomodate with the API of the rest of our tools. A demand is denoted by a negative supply.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>TODO(<a href="http://who/user">user</a>): See whether the following can bring any improvements on real-life problems. R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost flows by double scaling," Mathematical Programming, (1992) 53:243-266. <a href="http://www.springerlink.com/index/gu7404218u6kt166.pdf">http://www.springerlink.com/index/gu7404218u6kt166.pdf</a> </dd></dl>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file contains various shortestpaths utilities. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="6f44eda801f15f3cd9de08a5860bb5d6"></a><!-- doxytag: member="operations_research::ArcIndex" ref="6f44eda801f15f3cd9de08a5860bb5d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#6f44eda801f15f3cd9de08a5860bb5d6">operations_research::ArcIndex</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00093">93</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fb1f6bf36479d8f859d80a984fb2e391"></a><!-- doxytag: member="operations_research::ArcIndexArray" ref="fb1f6bf36479d8f859d80a984fb2e391" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PackedArray&lt;<a class="el" href="namespaceoperations__research.html#6fe2703e317fb0eaa16d155ae7a6ddba">kStarGraphArcIndexSize</a>&gt; <a class="el" href="namespaceoperations__research.html#fb1f6bf36479d8f859d80a984fb2e391">operations_research::ArcIndexArray</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00663">663</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a7950685633ee869aa9471b2ec5fbcfa"></a><!-- doxytag: member="operations_research::CostValue" ref="a7950685633ee869aa9471b2ec5fbcfa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#a7950685633ee869aa9471b2ec5fbcfa">operations_research::CostValue</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00095">95</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5841ff601ab08548afb15c45b2245de7"></a><!-- doxytag: member="operations_research::FlowQuantity" ref="5841ff601ab08548afb15c45b2245de7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#5841ff601ab08548afb15c45b2245de7">operations_research::FlowQuantity</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00094">94</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="bd22b9920b8b8f150cc9263533cebe1b"></a><!-- doxytag: member="operations_research::NodeIndex" ref="bd22b9920b8b8f150cc9263533cebe1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#bd22b9920b8b8f150cc9263533cebe1b">operations_research::NodeIndex</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00092">92</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="416534efbfb6234f89dd9f9053e9232a"></a><!-- doxytag: member="operations_research::NodeIndexArray" ref="416534efbfb6234f89dd9f9053e9232a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PackedArray&lt;<a class="el" href="namespaceoperations__research.html#95c8c3167a0caffc6f615bc28f674ff2">kStarGraphNodeIndexSize</a>&gt; <a class="el" href="namespaceoperations__research.html#416534efbfb6234f89dd9f9053e9232a">operations_research::NodeIndexArray</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00662">662</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="09767b3634289e432c3ce1d7c649666a"></a><!-- doxytag: member="operations_research::PathNodeIndex" ref="09767b3634289e432c3ce1d7c649666a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespaceoperations__research.html#09767b3634289e432c3ce1d7c649666a">operations_research::PathNodeIndex</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="hamiltonian__path_8h-source.html#l00086">86</a> of file <a class="el" href="hamiltonian__path_8h-source.html">hamiltonian_path.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ed5bb564de2974655b4759919bdadc10"></a><!-- doxytag: member="operations_research::StarGraph" ref="ed5bb564de2974655b4759919bdadc10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#95c8c3167a0caffc6f615bc28f674ff2">kStarGraphNodeIndexSize</a>, <a class="el" href="namespaceoperations__research.html#6fe2703e317fb0eaa16d155ae7a6ddba">kStarGraphArcIndexSize</a>&gt; <a class="el" href="classoperations__research_1_1EbertGraph.html">operations_research::StarGraph</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00661">661</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="891a1aa6cd60571a0d3a82c70c9de3c2"></a><!-- doxytag: member="operations_research::BellmanFordShortestPath" ref="891a1aa6cd60571a0d3a82c70c9de3c2" args="(int node_count, int start_node, int end_node, ResultCallback2&lt; int64, int, int &gt; *const graph, vector&lt; int &gt; *nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::BellmanFordShortestPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultCallback2&lt; int64, int, int &gt; *const &nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; *&nbsp;</td>
          <td class="paramname"> <em>nodes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bellman-Ford Shortest path with callback-based description of the graph. 
<p>
The callback returns the distance between two nodes, a distance of 'shortestpaths_disconnected_distance' (flag) indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. If true, it will fill the 'nodes' vector with the sequence of nodes on the shortest path between 'start_node' and 'end_node'. 
<p>Definition at line <a class="el" href="bellman__ford_8cc-source.html#l00115">115</a> of file <a class="el" href="bellman__ford_8cc-source.html">bellman_ford.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="e06e3ebda956e99a0771ad662d657ff3"></a><!-- doxytag: member="operations_research::CoverArcsByCliques" ref="e06e3ebda956e99a0771ad662d657ff3" args="(ResultCallback2&lt; bool, int, int &gt; *const graph, int node_count, ResultCallback1&lt; bool, const vector&lt; int &gt; &amp; &gt; *const callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::CoverArcsByCliques           </td>
          <td>(</td>
          <td class="paramtype">ResultCallback2&lt; bool, int, int &gt; *const &nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultCallback1&lt; bool, const vector&lt; int &gt; &amp; &gt; *const &nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will cover the maximum number of arcs of the graph with cliques. 
<p>
The graph is described by the graph callback. graph-&gt;Run(i, j) indicates if there is an arc between i and j. This method will delete the callbacks after it has run. It will call the 'callback' upon each cliques. It will ignore cliques of size one. 
<p>Definition at line <a class="el" href="bron__kerbosch_8cc-source.html#l00213">213</a> of file <a class="el" href="bron__kerbosch_8cc-source.html">bron_kerbosch.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="57679b4c15d8ddb5fe920952969685af"></a><!-- doxytag: member="operations_research::DijkstraShortestPath" ref="57679b4c15d8ddb5fe920952969685af" args="(int node_count, int start_node, int end_node, ResultCallback2&lt; int64, int, int &gt; *const graph, vector&lt; int &gt; *nodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::DijkstraShortestPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultCallback2&lt; int64, int, int &gt; *const &nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; *&nbsp;</td>
          <td class="paramname"> <em>nodes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dijsktra Shortest path with callback based description of the graph. 
<p>
The callback returns the distance between two nodes, a distance of 'shortestpaths_disconnected_distance' (flag) indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. 
<p>Definition at line <a class="el" href="dijkstra_8cc-source.html#l00156">156</a> of file <a class="el" href="dijkstra_8cc-source.html">dijkstra.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="03b2245563a4dc4d5dad9659ff992109"></a><!-- doxytag: member="operations_research::FindCliques" ref="03b2245563a4dc4d5dad9659ff992109" args="(ResultCallback2&lt; bool, int, int &gt; *const graph, int node_count, ResultCallback1&lt; bool, const vector&lt; int &gt; &amp; &gt; *const callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::FindCliques           </td>
          <td>(</td>
          <td class="paramtype">ResultCallback2&lt; bool, int, int &gt; *const &nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultCallback1&lt; bool, const vector&lt; int &gt; &amp; &gt; *const &nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
namespace 
<p>
This will find all maximal cliques, even with size 1, in the graph described by the graph callback.<p>
This method implements the 'version2' of the Bron-Kerbosch algorithm to find all maximal cliques in a undirected graph.<p>
graph-&gt;Run(i, j) indicates if there is an arc between i and j. This method will delete the callbacks after it has run. It will call the 'callback' upon each cliques. If the 'callback' returns true, then the search for cliques will stop. 
<p>Definition at line <a class="el" href="bron__kerbosch_8cc-source.html#l00191">191</a> of file <a class="el" href="bron__kerbosch_8cc-source.html">bron_kerbosch.cc</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="28fc2443c096ea8754eaa40697e4fc94"></a><!-- doxytag: member="operations_research::kHamiltonianPathSolverPadValue" ref="28fc2443c096ea8754eaa40697e4fc94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="namespaceoperations__research.html#28fc2443c096ea8754eaa40697e4fc94">operations_research::kHamiltonianPathSolverPadValue</a> = 1557<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="hamiltonian__path_8h-source.html#l00172">172</a> of file <a class="el" href="hamiltonian__path_8h-source.html">hamiltonian_path.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6fe2703e317fb0eaa16d155ae7a6ddba"></a><!-- doxytag: member="operations_research::kStarGraphArcIndexSize" ref="6fe2703e317fb0eaa16d155ae7a6ddba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="namespaceoperations__research.html#6fe2703e317fb0eaa16d155ae7a6ddba">operations_research::kStarGraphArcIndexSize</a> = 5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00660">660</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="95c8c3167a0caffc6f615bc28f674ff2"></a><!-- doxytag: member="operations_research::kStarGraphNodeIndexSize" ref="95c8c3167a0caffc6f615bc28f674ff2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="namespaceoperations__research.html#95c8c3167a0caffc6f615bc28f674ff2">operations_research::kStarGraphNodeIndexSize</a> = 5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard definition of the star representation of a graph, that makes it possible to address all the physical memory on a 2010 machine, while keeping the sizes of arcs and nodes reasonable. 
<p>
For most purposes it is sufficient to use this class. 
<p>Definition at line <a class="el" href="ebert__graph_8h-source.html#l00659">659</a> of file <a class="el" href="ebert__graph_8h-source.html">ebert_graph.h</a>.</p>

</div>
</div><p>
</div>

  <!-- Start of footer. -->
  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <tr valign=top>
      <td colspan=2 height=10></td>
    </tr>
    <tr valign=top>
      <td colspan=2 bgcolor=#389613 height=3></td>
    </tr>
  </table>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br />

  
  </body>
</html>
