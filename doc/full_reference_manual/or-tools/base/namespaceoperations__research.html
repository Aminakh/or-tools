<!-- Good morning, Mr. Phelps. -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>or-tools/base/: operations_research Namespace Reference - Doxy</title>
    <link rel="shortcut icon" href="../../favicon.ico">
    <!-- Both stylesheets are supplied by Doxygen, with maybe minor tweaks from Google. -->
    <link href="../../doxygen.css" rel="stylesheet" type="text/css">
    <link href="../../tabs.css" rel="stylesheet" type="text/css">
  </head>

  <body topmargin=0 leftmargin=20 bottommargin=0 rightmargin=20 marginwidth=20 marginheight=0>
  <!-- Second part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
  <style>
    a.doxy_logo:hover {
      background-color: #389613
    }
  </style>

  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <!-- Top horizontal line with the color of the day. -->
    <tr valign=top>
      <td colspan=3 bgcolor=#389613 height=3></td>
    </tr>

    <!-- Header row with the links at the right. -->
    <tr valign=top>
      <td colspan=3 align=right>
        <font size=-1>
          Generated on: <font color=#389613><b>Fri Apr  1 14:13:18 PDT 2011</b></font>
            for <b>custom file set</b>
        </font>
      </td>
    </tr>

    <!-- Header row with the logo and the search form. -->
    <tr valign=top>
      <!-- Logo. -->
      <td align=left width=150>
        <table width=150 height=54 cellpadding=0 cellspacing=0 border=0>
          <tr valign=top>
            <!-- First part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
            <td bgcolor=#389613>
              <a class="doxy_logo" href="../../index.html"><img src="../../doxy_logo.png" alt="Doxy" border=0></a>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <!-- Tiny vertical space below the form. -->
    <tr valign=top>
      <td colspan=3 height=3></td>
    </tr>
  </table>

  <!-- Header navigation row. -->
  <div class="memproto">
    <table width=100% cellpadding=0 cellspacing=0 border=0>
      <tr>
        <td align=left style="padding-left: 20px"><font size=+1><b><tt><font color=#333333>//
            <a href="../../index.html"><font color=#389613>doxy</font></a>/</font>
            <a href="../../or-tools/index.html">or-tools</a>/
            <a href="../../or-tools/base/index.html">base</a>/
            </tt></b></font>
        </td>
      </tr>
    </table>
  </div>
  <br />
    <!-- No subdirs found. -->
  <!-- End of header. -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>operations_research Namespace Reference</h1>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1AdjustablePriorityQueue.html">AdjustablePriorityQueue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Bitmap.html">Bitmap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1CallbackUtils__.html">CallbackUtils_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConstIter.html">ConstIter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MutableIter.html">MutableIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Note: this class is not compatible with sets (operator* returns a non-const reference).  <a href="classoperations__research_1_1MutableIter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConstReverseIter.html">ConstReverseIter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MutableReverseIter.html">MutableReverseIter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Eraser.html">Eraser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class performs an iterator-friendly erasure: the element pointed at gets removed from the container and the iterator remains valid and points to the next element.  <a href="classoperations__research_1_1Eraser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Eraser_3_01vector_3_01T_01_4_01_4.html">Eraser&lt; vector&lt; T &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This version of the <a class="el" href="classoperations__research_1_1Eraser.html" title="This class performs an iterator-friendly erasure: the element pointed at gets removed...">Eraser</a> works for vectors.  <a href="classoperations__research_1_1Eraser_3_01vector_3_01T_01_4_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Eraser_3_01deque_3_01T_01_4_01_4.html">Eraser&lt; deque&lt; T &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This version of the <a class="el" href="classoperations__research_1_1Eraser.html" title="This class performs an iterator-friendly erasure: the element pointed at gets removed...">Eraser</a> works for deques.  <a href="classoperations__research_1_1Eraser_3_01deque_3_01T_01_4_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DateLogger.html">DateLogger</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ACMRandom.html">ACMRandom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ACM minimal standard random number generator. (re-entrant.).  <a href="classoperations__research_1_1ACMRandom.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A scoped_ptr&lt;T&gt; is like a T*, except that the destructor of scoped_ptr&lt;T&gt; automatically deletes the pointer it holds (if any).  <a href="classoperations__research_1_1scoped__ptr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scoped_array&lt;C&gt; is like scoped_ptr&lt;C&gt;, except that the caller must allocate with new [] and the destructor deletes objects with delete [].  <a href="classoperations__research_1_1scoped__array.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ScopedPtrMallocFree.html">ScopedPtrMallocFree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class wraps the c library function free() in a class that can be passed as a template argument to <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html" title="scoped_ptr_malloc&lt;&gt; is similar to scoped_ptr&lt;&gt;, but it accepts a second...">scoped_ptr_malloc</a> below.  <a href="classoperations__research_1_1ScopedPtrMallocFree.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scoped_ptr_malloc&lt;&gt; is similar to scoped_ptr&lt;&gt;, but it accepts a second template argument, the functor used to free the object.  <a href="classoperations__research_1_1scoped__ptr__malloc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sparsetable.html">sparsetable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implement a simple block based sparse vector.  <a href="classoperations__research_1_1sparsetable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1WallTimer.html">WallTimer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CycleTimer.html">CycleTimer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class of timer is very precise and potentially more expensive than the <a class="el" href="classoperations__research_1_1WallTimer.html">WallTimer</a> class.  <a href="classoperations__research_1_1CycleTimer.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1anonymous__namespace_02random_8cc_03.html">anonymous_namespace{random.cc}</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research_1_1anonymous__namespace_02timer_8cc_03.html">anonymous_namespace{timer.cc}</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Walltimer. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#0bfe1fa5efe67aec28d43278d223fc33">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">StrCat.  <a href="#0bfe1fa5efe67aec28d43278d223fc33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#32bf8e225093acef245a29563ddfe53a">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p3)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#2c941151c1d1efe1920c79b635aa4da9">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p3, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p4)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#34b003fa5e759755c3b5a19379558db8">StrCat</a> (<a class="el" href="basictypes_8h.html#ecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> a1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#eb71a893e25aa9586a6a9beeb13c2350">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, <a class="el" href="basictypes_8h.html#ecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <br>
Collection::value_type::second_type &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#32af8158eed3df346e020ececd987195">FindWithDefault</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a lookup in a map or hash_map.  <a href="#32af8158eed3df346e020ececd987195"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <br>
Collection::value_type::second_type *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#320340a41d295ef6c2b62a4c27470a4f">FindOrNull</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a lookup in a map or hash_map.  <a href="#320340a41d295ef6c2b62a4c27470a4f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Collection::value_type::second_type *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#f94e1d869a173bb5441a32805e530ba7">FindOrNull</a> (Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a lookup in a map or hash_map.  <a href="#f94e1d869a173bb5441a32805e530ba7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <br>
Collection::value_type::second_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#5171f792b12cd655428a9e7b1ad7e492">FindPtrOrNull</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a lookup in a map or hash_map whose values are pointers.  <a href="#5171f792b12cd655428a9e7b1ad7e492"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection, class Key, class Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#683907a9b012bfbe41d16a3e2e1ad50b">InsertOrUpdate</a> (Collection *const collection, const Key &amp;key, const Value &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the value associated with a particular key in a map or hash_map.  <a href="#683907a9b012bfbe41d16a3e2e1ad50b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection, class Key, class Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#463dd381d13281748258aa5282e83ab3">InsertIfNotPresent</a> (Collection *const collection, const Key &amp;key, const Value &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new key and value into a map or hash_map.  <a href="#463dd381d13281748258aa5282e83ab3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection, class Key, class Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#df964e8253d1fd9cf94b44d7fbd13476">FindCopy</a> (const Collection &amp;collection, const Key &amp;key, Value *const value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a lookup in map or hash_map.  <a href="#df964e8253d1fd9cf94b44d7fbd13476"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection, class Key&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#8931adc07d6ce40dbf76f4276b62866e">ContainsKey</a> (const Collection &amp;collection, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test to see if a set, map, hash_set or hash_map contains a particular key.  <a href="#8931adc07d6ce40dbf76f4276b62866e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Collection&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <br>
Collection::value_type::second_type &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#19d13a6decfd83351e3a989f91089a63">FindOrDie</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#13ba46cedfb7cbcc4fe3ff4ded17940c">make_scoped_ptr</a> (C *param)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#cb7126a7ce64c0202692cace8d5836c4">swap</a> (<a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p1, <a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free functions.  <a href="#cb7126a7ce64c0202692cace8d5836c4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#83de577450e3e643e70eb4b9cbce0bc2">operator==</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#cf89ad51be992e280d58f6bface0d4d2">operator!=</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#5b291da4816d55628173cfda31e8f240">swap</a> (<a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p1, <a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free functions.  <a href="#5b291da4816d55628173cfda31e8f240"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#1ae18000cd717c97fc22637c9ee3dd02">operator==</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#e4f8c4f530635487e51c8a2959937b15">operator!=</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C, class FP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#3b8879b62e8f69a37d7b4b785b9481f9">swap</a> (<a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;a, <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C, class FP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#0a727025aa03594eff24275b8f99b6da">operator==</a> (C *p, const <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C, class FP&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#c4d7e523e2347b05cc575be678a57159">operator!=</a> (C *p, const <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#cacb98b70ed600596ef9db06c72773d4">STLDeleteContainerPointers</a> (ForwardIterator begin, ForwardIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#cacb98b70ed600596ef9db06c72773d4" title="STLDeleteContainerPointers() For a range within a container of pointers, calls delete...">STLDeleteContainerPointers()</a> For a range within a container of pointers, calls delete (non-array version) on these pointers.  <a href="#cacb98b70ed600596ef9db06c72773d4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#02badef7cd051b75c416757689542695">STLDeleteContainerPairSecondPointers</a> (ForwardIterator begin, ForwardIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#02badef7cd051b75c416757689542695" title="STLDeleteContainerPairSecondPointers() For a range within a container of pairs, calls...">STLDeleteContainerPairSecondPointers()</a> For a range within a container of pairs, calls delete (non-array version) on the SECOND item in the pairs.  <a href="#02badef7cd051b75c416757689542695"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#daf079622009b01172597a001fde299c">STLStringResizeUninitialized</a> (string *s, size_t new_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inside Google, this function implements a horrible, disgusting hack in which we reach into the string's private implementation and resize it without initializing the new bytes.  <a href="#daf079622009b01172597a001fde299c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ecd7a8e6141ddbeda4d1de71de1b3e24">string_as_array</a> (string *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a mutable char* pointing to a string's internal buffer, which may not be null-terminated.  <a href="#ecd7a8e6141ddbeda4d1de71de1b3e24"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#02adac4db026e3c0f1cd45a307472888">STLDeleteElements</a> (T *container)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#02adac4db026e3c0f1cd45a307472888" title="STLDeleteElements() deletes all the elements in an STL container and clears the container...">STLDeleteElements()</a> deletes all the elements in an STL container and clears the container.  <a href="#02adac4db026e3c0f1cd45a307472888"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#cc1208da53b8c9966104889d06555424">STLDeleteValues</a> (T *v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an STL container consisting of (key, value) pairs, STLDeleteValues deletes all the "value" components and clears the container.  <a href="#cc1208da53b8c9966104889d06555424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#1ba502bcb01644c4b9ffbee37c81b7a0">StringAppendV</a> (string *dst, const char *format, va_list ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#5440999daebfb3ec44e8f4f685cc1814">StringPrintf</a> (const char *format,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#9b1c98ae5d35dc2fcdde4d6d91bf88d9">SStringPrintf</a> (string *dst, const char *format,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#75a674b9c01ea4d84663449dc1b542eb">StringAppendF</a> (string *dst, const char *format,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a6647370e5e668a4a79c09d0e3269639">HasSuffixString</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;str, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;suffix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#a6647370e5e668a4a79c09d0e3269639" title="HasSuffixString() Return true if str ends in suffix.">HasSuffixString()</a> Return true if str ends in suffix.  <a href="#a6647370e5e668a4a79c09d0e3269639"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="basictypes_8h.html#ecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#f7311bc7b29234833be481c3b9a06448">GetProcessMemoryUsage</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GetProcessMemoryUsage.  <a href="#f7311bc7b29234833be481c3b9a06448"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#e3eb78859f8162620f6fffe8cac690af">mix</a> (<a class="el" href="basictypes_8h.html#1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;a, <a class="el" href="basictypes_8h.html#1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;b, <a class="el" href="basictypes_8h.html#1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#5cdda52220787f2b0cf8273197012f26">mix</a> (<a class="el" href="basictypes_8h.html#29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;a, <a class="el" href="basictypes_8h.html#29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;b, <a class="el" href="basictypes_8h.html#29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;c)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. 
<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This is an implementation designed to match the anticipated future TR2 implementation of the <a class="el" href="classoperations__research_1_1scoped__ptr.html" title="A scoped_ptr&lt;T&gt; is like a T*, except that the destructor of scoped_ptr&lt;T&gt;...">scoped_ptr</a> class, and its closely-related brethren, <a class="el" href="classoperations__research_1_1scoped__array.html" title="scoped_array&lt;C&gt; is like scoped_ptr&lt;C&gt;, except that the caller must allocate...">scoped_array</a>, <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html" title="scoped_ptr_malloc&lt;&gt; is similar to scoped_ptr&lt;&gt;, but it accepts a second...">scoped_ptr_malloc</a>, and make_scoped_ptr.<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A string-like object that points to a sized piece of memory.<p>
Functions or methods may use const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a>&amp; parameters to accept either a "const char*" or a "string" value that will be implicitly converted to a <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a>. The implicit conversion means that it is often appropriate to include this .h file in other files rather than forward-declaring <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> as would be appropriate for most other Google classes.<p>
Systematic usage of <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> is encouraged as it will reduce unnecessary conversions from "const char*" to "string" and back again.<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Mac OS X WINDOWS<p>
You may obtain a copy of the License at<p>
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><p>
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. C For size_t C++ Hash maps and hash sets are more problematic. <hr><h2>Function Documentation</h2>
<a class="anchor" name="8931adc07d6ce40dbf76f4276b62866e"></a><!-- doxytag: member="operations_research::ContainsKey" ref="8931adc07d6ce40dbf76f4276b62866e" args="(const Collection &amp;collection, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection, class Key&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::ContainsKey           </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test to see if a set, map, hash_set or hash_map contains a particular key. 
<p>
Returns true if the key is in the collection. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00130">130</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="df964e8253d1fd9cf94b44d7fbd13476"></a><!-- doxytag: member="operations_research::FindCopy" ref="df964e8253d1fd9cf94b44d7fbd13476" args="(const Collection &amp;collection, const Key &amp;key, Value *const value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection, class Key, class Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::FindCopy           </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *const &nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a lookup in map or hash_map. 
<p>
If the key is present and value is non-NULL then a copy of the value associated with the key is made into *value. Returns whether key was present. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00114">114</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="19d13a6decfd83351e3a989f91089a63"></a><!-- doxytag: member="operations_research::FindOrDie" ref="19d13a6decfd83351e3a989f91089a63" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type&amp; operations_research::FindOrDie           </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="map-util_8h-source.html#l00137">137</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f94e1d869a173bb5441a32805e530ba7"></a><!-- doxytag: member="operations_research::FindOrNull" ref="f94e1d869a173bb5441a32805e530ba7" args="(Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type::second_type* operations_research::FindOrNull           </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a lookup in a map or hash_map. 
<p>
Same as above but the returned pointer is not const and can be used to change the stored value. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>collection</em>&nbsp;</td><td>
NOLINT </td></tr>
</table>
</dl>
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00056">56</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="320340a41d295ef6c2b62a4c27470a4f"></a><!-- doxytag: member="operations_research::FindOrNull" ref="320340a41d295ef6c2b62a4c27470a4f" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type* operations_research::FindOrNull           </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a lookup in a map or hash_map. 
<p>
If the key is present a const pointer to the associated value is returned, otherwise a NULL pointer is returned. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00042">42</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5171f792b12cd655428a9e7b1ad7e492"></a><!-- doxytag: member="operations_research::FindPtrOrNull" ref="5171f792b12cd655428a9e7b1ad7e492" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type operations_research::FindPtrOrNull           </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a lookup in a map or hash_map whose values are pointers. 
<p>
If the key is present a const pointer to the associated value is returned, otherwise a NULL pointer is returned. This function does not distinguish between a missing key and a key mapped to a NULL value. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00072">72</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="32af8158eed3df346e020ececd987195"></a><!-- doxytag: member="operations_research::FindWithDefault" ref="32af8158eed3df346e020ececd987195" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type&amp; operations_research::FindWithDefault           </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::second_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a lookup in a map or hash_map. 
<p>
If the key is present in the map then the value associated with that key is returned, otherwise the value passed as a default is returned. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00027">27</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f7311bc7b29234833be481c3b9a06448"></a><!-- doxytag: member="operations_research::GetProcessMemoryUsage" ref="f7311bc7b29234833be481c3b9a06448" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="basictypes_8h.html#ecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> operations_research::GetProcessMemoryUsage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GetProcessMemoryUsage. 
<p>
Returns the memory usage of the process.<p>
Mac OS X LINUX WINDOWS &lt; Unknown, returning 0. 
<p>Definition at line <a class="el" href="sysinfo_8cc-source.html#l00074">74</a> of file <a class="el" href="sysinfo_8cc-source.html">sysinfo.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="a6647370e5e668a4a79c09d0e3269639"></a><!-- doxytag: member="operations_research::HasSuffixString" ref="a6647370e5e668a4a79c09d0e3269639" args="(const StringPiece &amp;str, const StringPiece &amp;suffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::HasSuffixString           </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>suffix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="namespaceoperations__research.html#a6647370e5e668a4a79c09d0e3269639" title="HasSuffixString() Return true if str ends in suffix.">HasSuffixString()</a> Return true if str ends in suffix. 
<p>

<p>Definition at line <a class="el" href="strutil_8h-source.html#l00026">26</a> of file <a class="el" href="strutil_8h-source.html">strutil.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="463dd381d13281748258aa5282e83ab3"></a><!-- doxytag: member="operations_research::InsertIfNotPresent" ref="463dd381d13281748258aa5282e83ab3" args="(Collection *const collection, const Key &amp;key, const Value &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection, class Key, class Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::InsertIfNotPresent           </td>
          <td>(</td>
          <td class="paramtype">Collection *const &nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a new key and value into a map or hash_map. 
<p>
If the key is not present in the map the key and value are inserted, otherwise nothing happens. True indicates that an insert took place, false indicates the key was already present. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00103">103</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="683907a9b012bfbe41d16a3e2e1ad50b"></a><!-- doxytag: member="operations_research::InsertOrUpdate" ref="683907a9b012bfbe41d16a3e2e1ad50b" args="(Collection *const collection, const Key &amp;key, const Value &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection, class Key, class Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::InsertOrUpdate           </td>
          <td>(</td>
          <td class="paramtype">Collection *const &nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the value associated with a particular key in a map or hash_map. 
<p>
If the key is not present in the map the key and value are inserted, otherwise the value is updated to be a copy of the value provided. True indicates that an insert took place, false indicates an update. 
<p>Definition at line <a class="el" href="map-util_8h-source.html#l00086">86</a> of file <a class="el" href="map-util_8h-source.html">map-util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="13ba46cedfb7cbcc4fe3ff4ded17940c"></a><!-- doxytag: member="operations_research::make_scoped_ptr" ref="13ba46cedfb7cbcc4fe3ff4ded17940c" args="(C *param)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; operations_research::make_scoped_ptr           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>param</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00146">146</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5cdda52220787f2b0cf8273197012f26"></a><!-- doxytag: member="operations_research::mix" ref="5cdda52220787f2b0cf8273197012f26" args="(uint64 &amp;a, uint64 &amp;b, uint64 &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void operations_research::mix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="util_8h-source.html#l00065">65</a> of file <a class="el" href="util_8h-source.html">util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e3eb78859f8162620f6fffe8cac690af"></a><!-- doxytag: member="operations_research::mix" ref="e3eb78859f8162620f6fffe8cac690af" args="(uint32 &amp;a, uint32 &amp;b, uint32 &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void operations_research::mix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="util_8h-source.html#l00053">53</a> of file <a class="el" href="util_8h-source.html">util.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4d7e523e2347b05cc575be678a57159"></a><!-- doxytag: member="operations_research::operator!=" ref="c4d7e523e2347b05cc575be678a57159" args="(C *p, const scoped_ptr_malloc&lt; C, FP &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C, class FP&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator!=           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr_malloc&lt; C, FP &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00377">377</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e4f8c4f530635487e51c8a2959937b15"></a><!-- doxytag: member="operations_research::operator!=" ref="e4f8c4f530635487e51c8a2959937b15" args="(C *p1, const scoped_array&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator!=           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_array&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00256">256</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cf89ad51be992e280d58f6bface0d4d2"></a><!-- doxytag: member="operations_research::operator!=" ref="cf89ad51be992e280d58f6bface0d4d2" args="(C *p1, const scoped_ptr&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator!=           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00141">141</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a727025aa03594eff24275b8f99b6da"></a><!-- doxytag: member="operations_research::operator==" ref="0a727025aa03594eff24275b8f99b6da" args="(C *p, const scoped_ptr_malloc&lt; C, FP &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C, class FP&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator==           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr_malloc&lt; C, FP &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00372">372</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1ae18000cd717c97fc22637c9ee3dd02"></a><!-- doxytag: member="operations_research::operator==" ref="1ae18000cd717c97fc22637c9ee3dd02" args="(C *p1, const scoped_array&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator==           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_array&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00251">251</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="83de577450e3e643e70eb4b9cbce0bc2"></a><!-- doxytag: member="operations_research::operator==" ref="83de577450e3e643e70eb4b9cbce0bc2" args="(C *p1, const scoped_ptr&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator==           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00136">136</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b1c98ae5d35dc2fcdde4d6d91bf88d9"></a><!-- doxytag: member="operations_research::SStringPrintf" ref="9b1c98ae5d35dc2fcdde4d6d91bf88d9" args="(string *dst, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::SStringPrintf           </td>
          <td>(</td>
          <td class="paramtype">string *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="stringprintf_8cc-source.html#l00081">81</a> of file <a class="el" href="stringprintf_8cc-source.html">stringprintf.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="02badef7cd051b75c416757689542695"></a><!-- doxytag: member="operations_research::STLDeleteContainerPairSecondPointers" ref="02badef7cd051b75c416757689542695" args="(ForwardIterator begin, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::STLDeleteContainerPairSecondPointers           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="namespaceoperations__research.html#02badef7cd051b75c416757689542695" title="STLDeleteContainerPairSecondPointers() For a range within a container of pairs, calls...">STLDeleteContainerPairSecondPointers()</a> For a range within a container of pairs, calls delete (non-array version) on the SECOND item in the pairs. 
<p>
NOTE: Like STLDeleteContainerPointers, deleting behind the iterator. Deleting the value does not always invalidate the iterator, but it may do so if the key is a pointer into the value object. 
<p>Definition at line <a class="el" href="stl__util-inl_8h-source.html#l00049">49</a> of file <a class="el" href="stl__util-inl_8h-source.html">stl_util-inl.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cacb98b70ed600596ef9db06c72773d4"></a><!-- doxytag: member="operations_research::STLDeleteContainerPointers" ref="cacb98b70ed600596ef9db06c72773d4" args="(ForwardIterator begin, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::STLDeleteContainerPointers           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="namespaceoperations__research.html#cacb98b70ed600596ef9db06c72773d4" title="STLDeleteContainerPointers() For a range within a container of pointers, calls delete...">STLDeleteContainerPointers()</a> For a range within a container of pointers, calls delete (non-array version) on these pointers. 
<p>
NOTE: for these three functions, we could just implement a DeleteObject functor and then call for_each() on the range and functor, but this requires us to pull in all of algorithm.h, which seems expensive. For hash_[multi]set, it is important that this deletes behind the iterator because the hash_set may call the hash function on the iterator when it is advanced, which could result in the hash function trying to deference a stale pointer. 
<p>Definition at line <a class="el" href="stl__util-inl_8h-source.html#l00033">33</a> of file <a class="el" href="stl__util-inl_8h-source.html">stl_util-inl.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="02adac4db026e3c0f1cd45a307472888"></a><!-- doxytag: member="operations_research::STLDeleteElements" ref="02adac4db026e3c0f1cd45a307472888" args="(T *container)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::STLDeleteElements           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>container</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="namespaceoperations__research.html#02adac4db026e3c0f1cd45a307472888" title="STLDeleteElements() deletes all the elements in an STL container and clears the container...">STLDeleteElements()</a> deletes all the elements in an STL container and clears the container. 
<p>
This function is suitable for use with a vector, set, hash_set, or any other STL container which defines sensible begin(), end(), and clear() methods.<p>
If container is NULL, this function is a no-op.<p>
As an alternative to calling <a class="el" href="namespaceoperations__research.html#02adac4db026e3c0f1cd45a307472888" title="STLDeleteElements() deletes all the elements in an STL container and clears the container...">STLDeleteElements()</a> directly, consider ElementDeleter (defined below), which ensures that your container's elements are deleted when the ElementDeleter goes out of scope. 
<p>Definition at line <a class="el" href="stl__util-inl_8h-source.html#l00096">96</a> of file <a class="el" href="stl__util-inl_8h-source.html">stl_util-inl.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cc1208da53b8c9966104889d06555424"></a><!-- doxytag: member="operations_research::STLDeleteValues" ref="cc1208da53b8c9966104889d06555424" args="(T *v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::STLDeleteValues           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an STL container consisting of (key, value) pairs, STLDeleteValues deletes all the "value" components and clears the container. 
<p>
Does nothing in the case it's given a NULL pointer. 
<p>Definition at line <a class="el" href="stl__util-inl_8h-source.html#l00107">107</a> of file <a class="el" href="stl__util-inl_8h-source.html">stl_util-inl.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="daf079622009b01172597a001fde299c"></a><!-- doxytag: member="operations_research::STLStringResizeUninitialized" ref="daf079622009b01172597a001fde299c" args="(string *s, size_t new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::STLStringResizeUninitialized           </td>
          <td>(</td>
          <td class="paramtype">string *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>new_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inside Google, this function implements a horrible, disgusting hack in which we reach into the string's private implementation and resize it without initializing the new bytes. 
<p>
In some cases doing this can significantly improve performance. However, since it's totally non-portable it has no place in open source code. Feel free to fill this function in with your own disgusting hack if you want the perf boost. 
<p>Definition at line <a class="el" href="stl__util-inl_8h-source.html#l00064">64</a> of file <a class="el" href="stl__util-inl_8h-source.html">stl_util-inl.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="eb71a893e25aa9586a6a9beeb13c2350"></a><!-- doxytag: member="operations_research::StrCat" ref="eb71a893e25aa9586a6a9beeb13c2350" args="(const StringPiece &amp;p1, int64 a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string operations_research::StrCat           </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#ecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="join_8cc-source.html#l00051">51</a> of file <a class="el" href="join_8cc-source.html">join.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="34b003fa5e759755c3b5a19379558db8"></a><!-- doxytag: member="operations_research::StrCat" ref="34b003fa5e759755c3b5a19379558db8" args="(int64 a1, const StringPiece &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string operations_research::StrCat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="basictypes_8h.html#ecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="join_8cc-source.html#l00047">47</a> of file <a class="el" href="join_8cc-source.html">join.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="2c941151c1d1efe1920c79b635aa4da9"></a><!-- doxytag: member="operations_research::StrCat" ref="2c941151c1d1efe1920c79b635aa4da9" args="(const StringPiece &amp;p1, const StringPiece &amp;p2, const StringPiece &amp;p3, const StringPiece &amp;p4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string operations_research::StrCat           </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="join_8cc-source.html#l00036">36</a> of file <a class="el" href="join_8cc-source.html">join.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="32bf8e225093acef245a29563ddfe53a"></a><!-- doxytag: member="operations_research::StrCat" ref="32bf8e225093acef245a29563ddfe53a" args="(const StringPiece &amp;p1, const StringPiece &amp;p2, const StringPiece &amp;p3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string operations_research::StrCat           </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="join_8cc-source.html#l00027">27</a> of file <a class="el" href="join_8cc-source.html">join.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="0bfe1fa5efe67aec28d43278d223fc33"></a><!-- doxytag: member="operations_research::StrCat" ref="0bfe1fa5efe67aec28d43278d223fc33" args="(const StringPiece &amp;p1, const StringPiece &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string operations_research::StrCat           </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
StrCat. 
<p>

<p>Definition at line <a class="el" href="join_8cc-source.html#l00021">21</a> of file <a class="el" href="join_8cc-source.html">join.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="ecd7a8e6141ddbeda4d1de71de1b3e24"></a><!-- doxytag: member="operations_research::string_as_array" ref="ecd7a8e6141ddbeda4d1de71de1b3e24" args="(string *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* operations_research::string_as_array           </td>
          <td>(</td>
          <td class="paramtype">string *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a mutable char* pointing to a string's internal buffer, which may not be null-terminated. 
<p>
Writing through this pointer will modify the string.<p>
string_as_array(&amp;str)[i] is valid for 0 &lt;= i &lt; str.size() until the next call to a string method that invalidates iterators.<p>
As of 2006-04, there is no standard-blessed way of getting a mutable reference to a string's internal buffer. However, issue 530 (<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#530">http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#530</a>) proposes this as the method. According to Matt Austern, this should already work on all current implementations. 
<p>Definition at line <a class="el" href="stl__util-inl_8h-source.html#l00080">80</a> of file <a class="el" href="stl__util-inl_8h-source.html">stl_util-inl.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="75a674b9c01ea4d84663449dc1b542eb"></a><!-- doxytag: member="operations_research::StringAppendF" ref="75a674b9c01ea4d84663449dc1b542eb" args="(string *dst, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::StringAppendF           </td>
          <td>(</td>
          <td class="paramtype">string *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="stringprintf_8cc-source.html#l00089">89</a> of file <a class="el" href="stringprintf_8cc-source.html">stringprintf.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="1ba502bcb01644c4b9ffbee37c81b7a0"></a><!-- doxytag: member="operations_research::StringAppendV" ref="1ba502bcb01644c4b9ffbee37c81b7a0" args="(string *dst, const char *format, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::StringAppendV           </td>
          <td>(</td>
          <td class="paramtype">string *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="stringprintf_8cc-source.html#l00019">19</a> of file <a class="el" href="stringprintf_8cc-source.html">stringprintf.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="5440999daebfb3ec44e8f4f685cc1814"></a><!-- doxytag: member="operations_research::StringPrintf" ref="5440999daebfb3ec44e8f4f685cc1814" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string operations_research::StringPrintf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="stringprintf_8cc-source.html#l00072">72</a> of file <a class="el" href="stringprintf_8cc-source.html">stringprintf.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="3b8879b62e8f69a37d7b4b785b9481f9"></a><!-- doxytag: member="operations_research::swap" ref="3b8879b62e8f69a37d7b4b785b9481f9" args="(scoped_ptr_malloc&lt; C, FP &gt; &amp;a, scoped_ptr_malloc&lt; C, FP &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C, class FP&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::swap           </td>
          <td>(</td>
          <td class="paramtype">scoped_ptr_malloc&lt; C, FP &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scoped_ptr_malloc&lt; C, FP &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00367">367</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5b291da4816d55628173cfda31e8f240"></a><!-- doxytag: member="operations_research::swap" ref="5b291da4816d55628173cfda31e8f240" args="(scoped_array&lt; C &gt; &amp;p1, scoped_array&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::swap           </td>
          <td>(</td>
          <td class="paramtype">scoped_array&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scoped_array&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free functions. 
<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00246">246</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb7126a7ce64c0202692cace8d5836c4"></a><!-- doxytag: member="operations_research::swap" ref="cb7126a7ce64c0202692cace8d5836c4" args="(scoped_ptr&lt; C &gt; &amp;p1, scoped_ptr&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::swap           </td>
          <td>(</td>
          <td class="paramtype">scoped_ptr&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scoped_ptr&lt; C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free functions. 
<p>

<p>Definition at line <a class="el" href="scoped__ptr_8h-source.html#l00131">131</a> of file <a class="el" href="scoped__ptr_8h-source.html">scoped_ptr.h</a>.</p>

</div>
</div><p>
</div>

  <!-- Start of footer. -->
  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <tr valign=top>
      <td colspan=2 height=10></td>
    </tr>
    <tr valign=top>
      <td colspan=2 bgcolor=#389613 height=3></td>
    </tr>
  </table>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br />

  
  </body>
</html>
