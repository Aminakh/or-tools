#summary Reference Manual

<wiki:toc max_depth="2" />

=Base Objects, Reversible States and Values=

==Base Objects==

A [BaseObject] is the root of all reversibly allocated objects.  A [DebugString] method is implemented.

{{{
class BaseObject {
 public:
  BaseObject() {}
  virtual ~BaseObject() {}
  virtual string DebugString() const;
};
}}}

An action is the base callback method. It is separated from the standard google callback class because of its specific memory management.
{{{
class Action : public BaseObject {
 public:
  Action();
  virtual ~Action();
  // The main callback of the class.
  virtual void Run(Solver* const s) = 0;
  // Pretty print method.
  virtual string DebugString() const;
};
}}}

The PropagationBaseObject is a subclass of BaseObject that is also friend to the Solver class. It allows accessing methods useful when writing new constraints or new expressions.
{{{
class PropagationBaseObject : public BaseObject {
 public:
  explicit PropagationBaseObject(Solver* const s) : solver_(s) {}
  virtual ~PropagationBaseObject() {}
  virtual string DebugString() const;
  Solver* solver() const { return solver_; }
  // This method freezes the propagation queue. It is useful when you need to apply multiple modifications at once.
  void FreezeQueue();
  // This method unfreezes the propagation queue. All modifications that happened when the queue was frozen will be processed.
  void UnfreezeQueue();
  // This method pushes the demon onto the propagation queue. It will be processed directly if the queue is empty. It will be enqueued according to its priority otherwise.
  void Enqueue(Demon* d);
  // This methods process all demons with priority non IMMEDIATE on the queue.
  void ProcessDemonsOnQueue() { solver_->ProcessDemonsOnQueue(); }
  // This method sets a callback that will be called if a failure happens during the propagation of the queue.
  void set_queue_action_on_fail(Action* a);
  // This methods clears the failure callback.
  void clear_queue_action_on_fail();
  // Naming
  string name() const;
  void set_name(const string& name);
};
}}}

A Demon is the base element of a propagation queue. It is the main object responsible for implementing the actual propagation of the constraint and pruning the inconsistent values in the domains of the variables. The main concept is that demons are listeners that are attached to the variables and listen to their 
modifications. There are two methods:
  * Run() is the actual methods that is called when the demon is processed
  * priority() returns its priority. Standart priorities are slow, normal or fast. immediate is reserved for variables and are treated separately.

{{{
enum DemonPriority { 
  DELAYED_PRIORITY = 0, 
  VAR_PRIORITY = 1, 
  NORMAL_PRIORITY = 2, 
}; 
class Demon : public BaseObject {
 public:
  // This indicates the priority of a demon. Immediate demons are treated separately and corresponds to variables.
  Demon();
  virtual ~Demon();
  // This is the main callback of the demon.
  virtual void Run(Solver* const s) = 0;
  // This method returns the priority of the demon. Usually a demon is fast, slow or normal. Immediate demons are reserved for internal use to maintain variables.
  virtual Solver::DemonPriority priority() const;
  // Pretty Print method.

  virtual string DebugString() const;
  // This method inhibits the demon in the search tree below the current position.
  void inhibit(Solver* const s);
  // This method un-inhibit the demon that was inhibited.
  void desinhibit(Solver* const s);
};
}}}

==Reversibility==

SaveValue() will save the value of the corresponding object. It must be called before modifying the object. The value will be restored upon backtrack.

{{{
template <class T> void Solver::SaveValue(T* o);
}}}

The RevAlloc method stores the corresponding object in a stack. When the solver will backtrack, it will loop through all stored objects and call delete on them. Supported object types are arrays of integers (32 and 64 bits), BaseObjects and arrays of BaseObjects. After a call to RevAlloc, solver takes ownership of the object memory and will delete the object itself. The user must not delete the object after it has be passed to the RevAlloc method.

{{{
template <class T> T* Solver::RevAlloc(T* o);
}}}

All-in-one SaveAndSetValue.

{{{
template <class T> void Solver::SaveAndSetValue(T* adr, T val);
}}}


All-in-one SaveAndAdd_value.

{{{
template <class T> void Solver::SaveAndAdd(T* adr, T val);
}}}

These class represent reversible POD types. It Contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree. Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.

{{{
template <class T> class Rev { 
 public: 
  explicit Rev(const T& val); 
  const T& Value() const;
  void SetValue(Solver* const s, const T& val);
};
}}}

=Integer Expressions=

The class IntExpr is the base of all integer expressions in constraint programming. It Contains the basic protocol for an expression: 
 * setting and modifying its bound
 * querying if it is bound
 * listening to events modifying its bounds
 * casting it into a variable (instance of IntVar)

{{{
class IntExpr : public PropagationBaseObject {
 public:
  explicit IntExpr(Solver* const s) : PropagationBaseObject(s) {} 
  virtual ~IntExpr() {}
  virtual int64 Min() const = 0;
  virtual void SetMin(int64 m) = 0;
  virtual int64 Max() const = 0;
  virtual void SetMax(int64 m) = 0;
  virtual void Range(int64* l, int64* u) { *l = Min(); *u = Max(); }
  virtual void SetRange(int64 l, int64 u) { SetMin(l); SetMax(u); }
  virtual void SetValue(int64 v) { SetRange(v, v); }
  virtual bool Bound() const { return (Min() == Max()); }
  virtual bool IsVar() const { return false; }
  virtual IntVar* Var() = 0;
  virtual void WhenRange(Demon* d) = 0;
};
}}}

Creates Sum expression.

{{{
IntExpr* Solver::MakeSum(IntExpr* const left, IntExpr* const right);
IntExpr* Solver::MakeSum(IntExpr* const expr, int64 value);
IntExpr* Solver::MakeSum(IntVar* const* vars, int size);
IntExpr* Solver::MakeSum(const vector<IntVar*>& vars);
}}}

Creates a scalar product of variables and coefficients.

{{{
IntExpr* Solver::MakeScalProd(const vector<IntVar*>& vars, const vector<int64>& coefs);
IntExpr* Solver::MakeScalProd(IntVar* const* vars, const int64* const coefs, int size);
IntExpr* Solver::MakeScalProd(const vector<IntVar*>& vars, const vector<int>& coefs);
IntExpr* Solver::MakeScalProd(IntVar* const* vars, const int* const coefs, int size);
}}}

Substraction

{{{
IntExpr* Solver::MakeDifference(IntExpr* const left, IntExpr* const right);
IntExpr* Solver::MakeDifference(int64 value, IntExpr* const expr);}}}
}}}

Opposite

{{{
IntExpr* Solver::MakeOpposite(IntExpr* const expr);
}}}

Product

{{{
IntExpr* Solver::MakeProd(IntExpr* const left, IntExpr* const right);
IntExpr* Solver::MakeProd(IntExpr* const expr, int64 value);
}}}

Integer division

{{{
IntExpr* Solver::MakeDiv(IntExpr* const expr, int64 value);
IntExpr* Solver::MakeDiv(IntExpr* const numerator, IntExpr* const denominator);
}}}

Absolute Value

{{{
IntExpr* Solver::MakeAbs(IntExpr* const expr);
}}}

Square

{{{
IntExpr* Solver::MakeSquare(IntExpr* const expr);
}}}

Element Expression (array of integer values indexed by a variable)
{{{
IntExpr* Solver::MakeElement(const int64* const vals, int size, IntVar* const index);
IntExpr* Solver::MakeElement(const vector<int64>& vals, IntVar* const index);
}}}

Function-based element
{{{
IntExpr* Solver::MakeElement(IndexEvaluator1* values, IntVar* const index);
}}}

2D version of function-based element expression, values(expr1, expr2).

{{{
IntExpr* Solver::MakeElement(IndexEvaluator2* values, IntVar* const index1, IntVar* const index2);
}}}


Array of variables indexed by another variable

{{{
IntExpr* Solver::MakeElement(const IntVar* const * vars, int size, IntVar* const index);
IntExpr* Solver::MakeElement(const vector<IntVar*>& vars, IntVar* const index);
}}}

Min of integer expressions

{{{
IntExpr* Solver::MakeMin(const vector<IntVar*>& vars);
IntExpr* Solver::MakeMin(IntVar* const* vars, int size);
IntExpr* Solver::MakeMin(IntExpr* const left, IntExpr* const right);
IntExpr* Solver::MakeMin(IntExpr* const expr, int64 val);
IntExpr* Solver::MakeMin(IntExpr* const expr, int val);
}}}

Max of integer expressions

{{{
IntExpr* Solver::MakeMax(const vector<IntVar*>& vars);
IntExpr* Solver::MakeMax(IntVar* const* vars, int size);
IntExpr* Solver::MakeMax(IntExpr* const left, IntExpr* const right);
IntExpr* Solver::MakeMax(IntExpr* const expr, int64 val);
IntExpr* Solver::MakeMax(IntExpr* const expr, int val);
}}}

U-shaped convex piecewise function.

{{{
IntExpr* Solver::MakeConvexPiecewiseExpr(IntVar* e, int64 early_cost, int64 early_date, int64 late_date, int64 late_cost);
}}}

Semi continuous Expression (x <= 0 -> f(x) = 0; x > 0 -> f(x) = ax + b) with a >= 0 and b >= 0

{{{
IntExpr* Solver::MakeSemiContinuousExpr(IntExpr* e, int64 fixed_charge, int64 step);
}}}

=Create Decision Variables=

The class Iterator has two direct subclasses. HoleIterators iterates over all holes, that is value removed between the current min and max of the variable since the last time the variable was processed in the queue. DomainIterators iterates over all elements of the variable domain. Both iterators are not robust to domain changes. Hole iterators can also report values outside the current min and max of the variable. HoleIterators should only be called from a demon attached to the variable that has created this iterator.

Example:
{{{
IntVar* current_var;
scoped_ptr<IntVarIterator> it(current_var->MakeHoleIterator(false));
for (it->Init(); it->Ok(); it->Next()) {
  const int64 hole = it->Value();
  // use the hole
}
}}}

{{{
class IntVarIterator : public BaseObject {
 public:
  virtual ~IntVarIterator() {}
  // This method must be called before each loop.
  virtual void Init() = 0;
  // This method indicates if we can call Value() or not.
  virtual bool Ok() const = 0;
  // This method returns the value of the hole.
  virtual int64 Value() const = 0;
  // This method moves the iterator to the next value.
  virtual void Next() = 0;
  // Pretty Print.
  virtual string DebugString() const;
};
}}}

The class IntVar is a subset of IntExpr. In addition to the IntExpr protocol, it offers persistance, removing values from the domains and a finer model for events

{{{
class IntVar : public IntExpr {
 public:
  explicit IntVar(Solver* const s) : IntExpr(s) {}
  IntVar(Solver* const s, const string& name) : IntExpr(s) { set_name(name); }
  virtual ~IntVar();
  virtual bool IsVar() const { return true; }
  virtual IntVar* Var() { return this; }
  // This method returns the value of the variable. This method checks before that the variable is bound.
  virtual int64 Value() const = 0;
  // This method removes the value 'v' from the domain of the variable.
  virtual void RemoveValue(int64 v) = 0;
  // This method removes the interval 'l' .. 'u' from the domain of the variable. It assumes that 'l' <= 'u'.
  virtual void RemoveInterval(int64 l, int64 u) = 0;
  // This method remove the values from the domain of the variable.
  virtual void RemoveValues(const int64* const values, int size);
  // This method remove the values from the domain of the variable.
  void RemoveValues(const vector<int64>& values);
  // This method intersects the current domain with the values in the array.
  virtual void SetValues(const int64* const values, int size);
  // This method intersects the current domain with the values in the array.
  void SetValues(const vector<int64>& values);
  // This method attaches a demon that will be awakened when the variable is bound.
  virtual void WhenBound(Demon* d) = 0;
  // This method attaches a demon that will watch any domain modification of the domain of the variable.
  virtual void WhenDomain(Demon* d) = 0;
  // This method returns the number of values in the domain of the variable.
  virtual uint64 Size() const = 0;
  // This method returns wether the value 'v' is in the domain of the variable.
  virtual bool Contains(int64 v) const = 0;
  // Creates a hole iterator. If reversible is false, the object is created on the normal C++ heap and the solver does NOT take ownership of the object.
  virtual IntVarIterator* MakeHoleIterator(bool reversible) const = 0;
  // Creates a domain iterator. If reversible is false, he object is created on the normal C++  heap and the solver does NOT take ownership of the object.
  virtual IntVarIterator* MakeDomainIterator(bool reversible) const = 0;
  // Returns the previous min.
  virtual int64 OldMin() const = 0;
  // Returns the previous max.
  virtual int64 OldMax() const = 0;
  virtual int VarType() const;
};
}}}

MakeIntVar will create the best range based int var for the bounds given.

{{{
IntVar* Solver::MakeIntVar(int64 vmin, int64 vmax, const string& name);
IntVar* Solver::MakeIntVar(int64 vmin, int64 vmax);
}}}

MakeIntVar will create a variable with the given sparse domain.

{{{
IntVar* Solver::MakeIntVar(const vector<int64>& values, const string& name);
IntVar* Solver::MakeIntVar(const vector<int64>& values);
}}}

MakeBoolVar will create a variable with a {0, 1} domain.

{{{
IntVar* Solver::MakeBoolVar(const string& name);
IntVar* Solver::MakeBoolVar();
}}}

IntConst will create a constant expression.

{{{
IntVar* Solver::MakeIntConst(int64 val, const string& name);
IntVar* Solver::MakeIntConst(int64 val);
}}}

This method will append the vector vars with _`var_count`_ variables having bounds vmin and vmax and having name "name<i>" where <i> is the index of the variable.

{{{
void Solver::MakeIntVarArray(int var_count, int64 vmin, int64 vmax, const string& name, vector<IntVar*>* vars);
void Solver::MakeIntVarArray(int var_count, int64 vmin, int64 vmax, vector<IntVar*>* vars);
}}}

Same but allocates an array and returns it.
{{{
IntVar** Solver::MakeIntVarArray(int var_count, int64 vmin, int64 vmax, const string& name);
}}}

This method will append the vector vars with 'var_count' boolean variables having name "name<i>" where <i> is the index of the variable.

{{{
void Solver::MakeBoolVarArray(int var_count, const string& name, vector<IntVar*>* vars);
void Solver::MakeBoolVarArray(int var_count, vector<IntVar*>* vars);
}}}

Same but allocates an array and returns it.

{{{
IntVar** Solver::MakeBoolVarArray(int var_count, const string& name);
}}}

=Constraints=

A constraint is the main modeling object. It proposes two methods:

  * Post() is responsible for creating the demons and attaching them to immediate demons()
  * InitialPropagate() is called once just after the Post and performs the initial propagation. The subsequent propagations will be performed by the demons Posted during the post() method.

{{{
class Constraint : public PropagationBaseObject {
 public:
  explicit Constraint(Solver* const solver);
  virtual ~Constraint();
  // This method is called when the constraint is processed by the solver. Its main usage is to attach demons to variables.
  virtual void Post() = 0;
  // This method performs the initial propagation of the constraint. It is called just after the post. 
  virtual void InitialPropagate() = 0;
  // Pretty print method.
  virtual string DebugString() const;
};
}}}

This method adds the constraint "c" to the solver. 

{{{
void Solver::AddConstraint(Constraint* const c); 
}}}

This constraint always succeeds.

{{{
Constraint* Solver::MakeTrueConstraint();
}}}

This constraint always fails.

{{{
Constraint* Solver::MakeFalseConstraint();
}}}

b == (v == c)
Constraint* Solver::MakeIsEqualCstCt(IntVar* const v, int64 c, IntVar* const b);

Status var of (v == c)
IntVar* Solver::MakeIsEqualCstVar(IntVar* const var, int64 value);

b == (v1 == v2)
Constraint* Solver::MakeIsEqualCt(IntExpr* const v1, IntExpr* v2, IntVar* const b);

Status var of (v1 == v2)
IntVar* Solver::MakeIsEqualVar(IntExpr* const var, IntExpr* v2);

Equality constraint
Constraint* Solver::MakeEquality(IntVar* const left, IntVar* const right);
Constraint* Solver::MakeEquality(IntExpr* const expr, int64 value);
Constraint* Solver::MakeEquality(IntExpr* const expr, int value);


b == (v != c)
Constraint* Solver::MakeIsDifferentCstCt(IntVar* const v, int64 c, IntVar* const b);

Status var of (v != c)
IntVar* Solver::MakeIsDifferentCstVar(IntVar* const v, int64 c);

Status var of (v1 != v2)
IntVar* Solver::MakeIsDifferentVar(IntExpr* const v1, IntExpr* const v2);

b == (v1 != v2)
Constraint* Solver::MakeIsDifferentCt(IntExpr* const v1, IntExpr* const v2, IntVar* const b);

Inequality Constraint
Constraint* Solver::MakeNonEquality(IntVar* const left, IntVar* const right);
Constraint* Solver::MakeNonEquality(IntVar* const expr, int64 value);
Constraint* Solver::MakeNonEquality(IntVar* const expr, int value);

b == (v <= c)
Constraint* Solver::MakeIsLessOrEqualCstCt(IntVar* const v, int64 c, IntVar* const b);

Status var of (v <= c)
IntVar* Solver::MakeIsLessOrEqualCstVar(IntVar* const v, int64 c);

Status var of (left <= right)
IntVar* Solver::MakeIsLessOrEqualVar(IntExpr* const left, IntExpr* const right);

b == (left <= right)
Constraint* Solver::MakeIsLessOrEqualCt(IntExpr* const left, IntExpr* const right, IntVar* const b);

<= constraint
Constraint* Solver::MakeLessOrEqual(IntVar* const left, IntVar* const right);
Constraint* Solver::MakeLessOrEqual(IntExpr* const expr, int64 value);
Constraint* Solver::MakeLessOrEqual(IntExpr* const expr, int value);

b == (v >= c)
Constraint* Solver::MakeIsGreaterOrEqualCstCt(IntVar* const v, int64 c, IntVar* const b);

Status var of (v >= c)
IntVar* Solver::MakeIsGreaterOrEqualCstVar(IntVar* const v, int64 c);

Status var of (left >= right)
IntVar* Solver::MakeIsGreaterOrEqualVar(IntExpr* const left, IntExpr* const right);

b == (left >= right)
Constraint* Solver::MakeIsGreaterOrEqualCt(IntExpr* const left, IntExpr* const right, IntVar* const b);

Greater or Equal Constraint
Constraint* Solver::MakeGreaterOrEqual(IntVar* const left, IntVar* const right);
Constraint* Solver::MakeGreaterOrEqual(IntExpr* const expr, int64 value);
Constraint* Solver::MakeGreaterOrEqual(IntExpr* const expr, int value);

b == (v > c)
Constraint* Solver::MakeIsGreaterCstCt(IntVar* const v, int64 c, IntVar* const b);

Status var of (v > c)
IntVar* Solver::MakeIsGreaterCstVar(IntVar* const v, int64 c);

Status var of (left > right)
IntVar* Solver::MakeIsGreaterVar(IntExpr* const left, IntExpr* const right);

b == (left > right)
Constraint* Solver::MakeIsGreaterCt(IntExpr* const left, IntExpr* const right, IntVar* const b);

Greater Constraint
Constraint* Solver::MakeGreater(IntVar* const left, IntVar* const right);
Constraint* Solver::MakeGreater(IntExpr* const expr, int64 value);
Constraint* Solver::MakeGreater(IntExpr* const expr, int value);

b == (v < c)
Constraint* Solver::MakeIsLessCstCt(IntVar* const v, int64 c, IntVar* const b);

Status var of (v < c)
IntVar* Solver::MakeIsLessCstVar(IntVar* const v, int64 c);

Status var of (left < right)
IntVar* Solver::MakeIsLessVar(IntExpr* const left, IntExpr* const right);

b == (left < right)
Constraint* Solver::MakeIsLessCt(IntExpr* const left, IntExpr* const right, IntVar* const b);

Less Constraint
Constraint* Solver::MakeLess(IntVar* const left, IntVar* const right);
Constraint* Solver::MakeLess(IntExpr* const expr, int64 value);
Constraint* Solver::MakeLess(IntExpr* const expr, int value);

Variation on arrays.
Constraint* Solver::MakeSumLessOrEqual(const vector<IntVar*>& vars, int64 cst);
Constraint* Solver::MakeSumLessOrEqual(IntVar* const* vars, int size, int64 cst);
Constraint* Solver::MakeSumGreaterOrEqual(const vector<IntVar*>& vars, int64 cst);
Constraint* Solver::MakeSumGreaterOrEqual(IntVar* const* vars, int size, int64 cst);
Constraint* Solver::MakeSumEquality(const vector<IntVar*>& vars, int64 cst);
Constraint* Solver::MakeSumEquality(IntVar* const* vars, int size, int64 cst);
Constraint* Solver::MakeScalProdEquality(const vector<IntVar*>& vars, const vector<int64>& coefficients, int64 cst);
Constraint* Solver::MakeScalProdEquality(IntVar* const* vars, int size, int64 const * coefficients, int64 cst);
Constraint* Solver::MakeScalProdEquality(IntVar* const* vars, int size, int const * coefficients, int64 cst);
Constraint* Solver::MakeScalProdEquality(const vector<IntVar*>& vars, const vector<int>& coefficients, int64 cst);
Constraint* Solver::MakeScalProdGreaterOrEqual(const vector<IntVar*>& vars, const vector<int64>& coefficients, int64 cst);
Constraint* Solver::MakeScalProdGreaterOrEqual(IntVar* const* vars, int size, int64 const * coefficients, int64 cst);
Constraint* Solver::MakeScalProdGreaterOrEqual(const vector<IntVar*>& vars, const vector<int>& coefficients, int64 cst);
Constraint* Solver::MakeScalProdGreaterOrEqual(IntVar* const* vars, int size, int const * coefficients, int64 cst);
Constraint* Solver::MakeScalProdLessOrEqual(const vector<IntVar*>& vars, const vector<int64>& coefficients, int64 cst);
Constraint* Solver::MakeScalProdLessOrEqual(IntVar* const* vars, int size, int64 const * coefficients, int64 cst);
Constraint* Solver::MakeScalProdLessOrEqual(const vector<IntVar*>& vars, const vector<int>& coefficients, int64 cst);
Constraint* Solver::MakeScalProdLessOrEqual(IntVar* const* vars, int size, int const * coefficients, int64 cst);

This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint 'ct'.
Demon* Solver::MakeConstraintInitialPropagateCallback(Constraint* const ct);

The same demon, but with a lower priority.
Demon* Solver::MakeDelayedConstraintInitialPropagateCallback(Constraint* const ct);

(l <= b <= u)
Constraint* Solver::MakeBetweenCt(IntVar* const v, int64 l, int64 u);

b == (l <= v <= u)
Constraint* Solver::MakeIsBetweenCt(IntVar* const v, int64 l, int64 u, IntVar* const b);

b == (v in set)
Constraint* Solver::MakeIsMemberCt(IntVar* const v, const int64* const values, int size, IntVar* const b);
Constraint* Solver::MakeIsMemberCt(IntVar* const v, const vector<int64>& values, IntVar* const b);

Status var of (v in set)
IntVar* Solver::MakeIsMemberVar(IntVar* const v, const int64* const values, int size);
IntVar* Solver::MakeIsMemberVar(IntVar* const v, const vector<int64>& values);

Membership constraint (v in set). Propagation is lazy, i.e. this constraint does not creates holes in the domain of the variable.
Constraint* Solver::MakeMemberCt(IntVar* const v, const int64* const values, int size);
Constraint* Solver::MakeMemberCt(IntVar* const v, const vector<int64>& values);

|{i | v[i] == value}| == count
Constraint* Solver::MakeCount(const vector<IntVar*>& v, int64 value, int64 count);
Constraint* Solver::MakeCount(const vector<IntVar*>& v, int64 value, IntVar* const count);

Aggregated version of count: |{i | v[i] == values[j]}| == cards[j]
Constraint* Solver::MakeDistribute(const vector<IntVar*>& vars, const vector<int64>& values, const vector<IntVar*>& cards);

Aggregated version of count: |{i | v[i] == j}| == cards[j]
Constraint* Solver::MakeDistribute(const vector<IntVar*>& vars, const vector<IntVar*>& cards);

Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1: card_min <= |{i | v[i] == j}| <= card_max
Constraint* Solver::MakeDistribute(const vector<IntVar*>& vars, int64 card_min, int64 card_max, int64 card_size);

All variables are pairwise different. If range is true, then the propagation is a bit more costly, and more effective.
Constraint* Solver::MakeAllDifferent(const vector<IntVar*>& vars, bool range);
Constraint* Solver::MakeAllDifferent(const IntVar* const* vars,int size, bool range);

Prevent cycles, nexts variables representing the next in the chain. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. A callback can be added to specify sink values (by default sink values are values >= vars.size()). Ownership of the callback is passed to the constraint. If assume_paths is either not specified or true, the constraint assumes the 'next' variables represent paths (and performs a faster propagation); otherwise the constraint assumes the 'next' variables represent a forest.
Constraint* Solver::MakeNoCycle(const vector<IntVar*>& nexts, const vector<IntVar*>& active, ResultCallback1<bool, int64>* sink_handler = NULL);
Constraint* Solver::MakeNoCycle(const IntVar* const* nexts, const IntVar* const* active, int size, ResultCallback1<bool, int64>* sink_handler = NULL);
Constraint* Solver::MakeNoCycle(const vector<IntVar*>& nexts, const vector<IntVar*>& active, ResultCallback1<bool, int64>* sink_handler, bool assume_paths);
Constraint* Solver::MakeNoCycle(const IntVar* const* nexts, const IntVar* const* active, int size, ResultCallback1<bool, int64>* sink_handler, bool assume_paths);

Accumulate values along a path such that: cumuls[next[i]] = cumuls[i] + transits[i].
Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem.
Constraint* Solver::MakePathCumul(const vector<IntVar*>& nexts, const vector<IntVar*>& active,const vector<IntVar*>& cumuls, const vector<IntVar*>& transits);
Constraint* Solver::MakePathCumul(const IntVar* const* nexts, const IntVar* const* active, const IntVar* const* cumuls, const IntVar* const* transits, int next_size, int cumul_size);

This constraint maps the domain of 'var' onto the array of variables 'vars'. That is for all i in [0 .. size - 1]: vars[i] == 1 <=> var->Contains(i);
Constraint* Solver::MakeMapDomain(IntVar* const var, IntVar* const * vars, int size);
Constraint* Solver::MakeMapDomain(IntVar* const var, const vector<IntVar*>& vars);

This method creates a constraint where the graph of the relation between the variables is given in extension. There are 'arity' variables involved in the relation and the graph is given by a matrix of size 'tuple_count' x 'arity'.
Constraint* Solver::MakeAllowedAssignments(const IntVar* const * vars, const int64* const * tuples, int tuple_count, int arity);
Constraint* Solver::MakeAllowedAssignments(const vector<IntVar*>& vars, const vector<vector<int64> >& tuples);

Packing constraint
class Pack : public Constraint {
 public:
  Pack(Solver* const s, const IntVar* const * vars, int vsize, int64 number_of_bins);
  virtual ~Pack();
  // ----- Public API -----
  // Dimensions are additional constraints than can restrict what is possible with the pack constraint. It can be used to set capacity limits, to count objects per bin, to compute unassigned penalties...

  // This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to 'b' is less or equal 'bounds[b]'.
  void AddWeightedSumLessOrEqualConstantDimension(const vector<int64>& weights, const vector<int64>& bounds);

  // This dimension enforces that cost_var == sum of weights[i] for all objects 'i' assigned to a bin.
  void AddWeightedSumOfAssignedDimension(const vector<int64>& weights, IntVar* const cost_var);

  // This dimension links 'count_var' to the actual number of bins used in the pack.
  void AddCountUsedBinDimension(IntVar* const count_var);

  // This dimension links 'count_var' to the actual number of items assigned to a bin in the pack.
  void AddCountAssignedItemsDimension(IntVar* const count_var);
};

This constraint packs all variables onto 'number_of_bins' variables. For any given variable, a value of 'number_of_bins' indicates that the variable is not assigned to any bin. Dimensions, i.e. cumulative constraints on this packing can be added directly from the pack class.
Pack* Solver::MakePack(const vector<IntVar*>& vars, int number_of_bins);
Scheduling

Intervals

An interval var is often used in scheduling. Its main characteristics are its start position, its duration and its end date. All these characteristics can be queried, set and demons can be posted on their modifications. An important aspect is optionality. An interval var can be performed or not. If unperformed, then it simply does not exist. Its characteristics cannot be accessed anymore. An interval var is automatically marked as unperformed when it is not consistent anymore (start greater than end, duration < 0...)

class IntervalVar : public PropagationBaseObject {
 public:
  IntervalVar(Solver* const s, const string& name);
  virtual ~IntervalVar();
  // These methods query, set and watch the start position of the interval var.
  virtual int64 StartMin() const = 0;
  virtual int64 StartMax() const = 0;
  virtual void SetStartMin(int64 m) = 0;
  virtual void SetStartMax(int64 m) = 0;
  virtual void SetStartRange(int64 mi, int64 ma) = 0;
  virtual void WhenStartRange(Demon* const d) = 0;
  virtual void WhenStartBound(Demon* const d) = 0;

  // These methods query, set and watch the duration of the interval var.
  virtual int64 DurationMin() const = 0;
  virtual int64 DurationMax() const = 0;
  virtual void SetDurationMin(int64 m) = 0;
  virtual void SetDurationMax(int64 m) = 0;
  virtual void SetDurationRange(int64 mi, int64 ma) = 0;
  virtual void WhenDurationRange(Demon* const d) = 0;
  virtual void WhenDurationBound(Demon* const d) = 0;

  // These methods query, set and watch the end position of the interval var.
  virtual int64 EndMin() const = 0;
  virtual int64 EndMax() const = 0;
  virtual void SetEndMin(int64 m) = 0;
  virtual void SetEndMax(int64 m) = 0;
  virtual void SetEndRange(int64 mi, int64 ma) = 0;
  virtual void WhenEndRange(Demon* const d) = 0;
  virtual void WhenEndBound(Demon* const d) = 0;

  // These methods query, set and watches the performed status of the interval var.
  virtual bool PerformedMin() const = 0;
  virtual bool PerformedMax() const = 0;
  virtual void SetPerformed(bool val) = 0;
  virtual void WhenPerformedBound(Demon* const d) = 0;

  // These methods creates expressions encapsulating the start, end and duration of the interval var. Please note that these must not be used if the interval var is unperformed.
  IntExpr* StartExpr();
  IntExpr* DurationExpr();
  IntExpr* EndExpr();
  IntExpr* PerformedExpr();
};

Creates an interval var with a fixed duration. The duration must be greater than 0. If optional is true, then the interval can be performed or unperformed. If optional is false, then the interval is always performed.

IntervalVar* Solver::MakeFixedDurationIntervalVar(int64 start_min, int64 start_max, int64 duration, bool optional, const string& name);

Creates an fixed and performed interval.

IntervalVar* Solver::MakeFixedInterval(int64 start, int64 duration, const string& name);
Scheduling Constraints

This method creates a relation between an interval var and a date.
enum UnaryIntervalRelation {
  ENDS_AFTER,
  ENDS_AT,
  ENDS_BEFORE,
  STARTS_AFTER,
  STARTS_AT,
  STARTS_BEFORE,
  CROSS_DATE,
  AVOID_DATE
};
Constraint* Solver::MakeIntervalVarRelation(IntervalVar* const t, UnaryIntervalRelation r, int64 d);
This method creates a relation between two an interval vars.

enum BinaryIntervalRelation {
  ENDS_AFTER_END,
  ENDS_AFTER_START,
  ENDS_AT_END,
  ENDS_AT_START,
  STARTS_AFTER_END,
  STARTS_AFTER_START,
  STARTS_AT_END,
  STARTS_AT_START
};
Constraint* Solver::MakeIntervalVarRelation(IntervalVar* const t1, BinaryIntervalRelation r, IntervalVar* const t2);

This constraint implements a temporal disjunction between two interval vars t1 and t2. 'alt' indicates which alternative was chosen (alt == 0 is equivalent to t1 before t2).
Constraint* Solver::MakeTemporalDisjunction(IntervalVar* const t1, IntervalVar* const t2, IntVar* const alt);

This constraint implements a temporal disjunction between two interval vars.
Constraint* Solver::MakeTemporalDisjunction(IntervalVar* const t1, IntervalVar* const t2);
Sequence

A sequence is groups an array of interval vars and force them into a sequence. It exports statistics about its interval states such that it can be used in a decision builder. The most important ones are PossibleFirst() which tells if an interval var can be ranked first and RankFirst/RankNotFirst which can be used to create the search decision.

class Sequence : public Constraint {
 public:
  enum State { ONE_BEFORE_TWO, TWO_BEFORE_ONE, UNDECIDED };
  Sequence(Solver* const s, const IntervalVar* const * intervals, int size, const string& name);
  virtual ~Sequence();
  // Pretty Print Method.
  virtual string DebugString() const;
  // Constraint protocol: post demons.
  virtual void Post();
  // Constraint protocol: Initial propagation
  virtual void InitialPropagate();
  // Returns the minimum and maximum duration of combined interval vars in the sequence.
  void DurationRange(int64* dmin, int64* dmax) const;
  // Returns the minimum start min and the maximum end max of all interval vars in the sequence.
  void HorizonRange(int64* hmin, int64* hmax) const;
  // Returns the minimum start min and the maximum end max of all unranked interval vars in the sequence.
  void ActiveHorizonRange(int64* hmin, int64* hmax) const;
  // Returns the number of interval vars already ranked.
  int Ranked() const;
  // Returns the number of interval vars not yet ranked.
  int NotRanked() const;
  // Returns the number of interval vars not unperformed.
  int Active() const;
  // Returns the number of interval vars fixed and performed.
  int Fixed() const;
  // TODO(user) : hide ComputePossibleRanks() method.
  void ComputePossibleRanks();
  // Returns whether or not the index_th interval var in the sequence can be ranked first of all unranked interval vars.
  bool PossibleFirst(int index);
  // Rank the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.
  void RankFirst(int index);
  // Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.
  void RankNotFirst(int index);
  // Returns the index_th interval of the sequence.
  IntervalVar* Interval(int index) const;
  // Returns the number of interval vars in the sequence.
  int size() const { return size_; }
};
This constraint forces all interval vars into an non overlapping sequence and creates a sequence object.
Sequence* Solver::MakeSequence(const vector<IntervalVar*>& intervals, const string& name);
Sequence* Solver::MakeSequence(const IntervalVar* const * intervals, int size, const string& name);

Tree Search Definition

Classes and Enums

A Decision represents a choice point in the search tree. The two main methods are Apply() to go left, or Refute() to go right.
class Decision : public BaseObject {
 public:
  Decision() {}
  virtual ~Decision() {}
  // Apply will be called first when the decision is executed.
  virtual void Apply(Solver* const s) = 0;
  // Refute will be called after a backtrack.
  virtual void Refute(Solver* const s) = 0;
  // Pretty print method.
  virtual string DebugString() const;
  // Visits the decision.
  virtual void Accept(DecisionVisitor* const visitor) const;
};


A DecisionVisitor is used to inspect a decision. It contains virtual methods for all type of 'declared' decisions.

class DecisionVisitor : public BaseObject {
 public:
  DecisionVisitor() {}
  virtual ~DecisionVisitor() {}
  virtual void VisitSetVariableValue(IntVar* const var, int64 value);
  virtual void VisitUnknownDecision();
 };


A DecisionBuilder is responsible for creating the search tree. The important method is Next() that returns the next decision to execute.

class DecisionBuilder : public BaseObject {
 public:
  DecisionBuilder() {}
  virtual ~DecisionBuilder() {}
  // This is the main method of the decision builder class. It must return a decision (an instance of the class Decision). If it returns NULL, this means that the decision builder has finished its work.
  virtual Decision* Next(Solver* const s) = 0;
  // Pretty print method.
  virtual string DebugString() const { return "DecisionBuilder"; }
};

These enums are used to specify predefined strategies.
enum IntVarStrategy {
 INT_VAR_DEFAULT,
 INT_VAR_SIMPLE,
 CHOOSE_FIRST_UNBOUND,
 CHOOSE_RANDOM,
 CHOOSE_MIN_SIZE_LOWEST_MIN,
 CHOOSE_MIN_SIZE_HIGHEST_MIN,
 CHOOSE_MIN_SIZE_LOWEST_MAX,
 CHOOSE_MIN_SIZE_HIGHEST_MAX,
 CHOOSE_PATH,
};
 
enum IntValueStrategy {
 INT_VALUE_DEFAULT,
 INT_VALUE_SIMPLE,
 ASSIGN_MIN_VALUE,
 ASSIGN_MAX_VALUE,
 ASSIGN_RANDOM_VALUE,
 ASSIGN_CENTER_VALUE
 };

enum EvaluatorStrategy {
 CHOOSE_STATIC_GLOBAL_BEST,
 CHOOSE_DYNAMIC_GLOBAL_BEST,
};

enum SequenceStrategy {
 SEQUENCE_DEFAULT,
 SEQUENCE_SIMPLE,
 CHOOSE_MIN_SLACK_RANK_FORWARD
};

enum IntervalStrategy {
 INTERVAL_DEFAULT,
 INTERVAL_SIMPLE,
 INTERVAL_SET_TIMES_FORWARD
};

Search Decicions and Decision Builders

These are the predefined decisions
Decision* Solver::MakeAssignVariableValue(IntVar* const var, int64 value);
Decision* Solver::MakeAssignVariablesValues(const IntVar* const* vars, int size, const int64* const values);
Decision* Solver::MakeAssignVariablesValues(const vector<IntVar*>& vars, const vector<int64>& values);
Decision* Solver::MakeFailDecision();

Sequential composition of Decision Builders
DecisionBuilder* Compose(DecisionBuilder* const db1, DecisionBuilder* const db2);
DecisionBuilder* Compose(DecisionBuilder* const db1, DecisionBuilder* const db2, DecisionBuilder* const db3);
DecisionBuilder* Compose(DecisionBuilder* const db1, DecisionBuilder* const db2, DecisionBuilder* const db3, DecisionBuilder* const db4);
DecisionBuilder* Compose(const vector<DecisionBuilder*>& dbs);

Phases on IntVar arrays.
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IntVarStrategy var_str, IntValueStrategy val_str);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IntVarStrategy var_str, IntValueStrategy val_str);
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IndexEvaluator1* var_evaluator, IntValueStrategy val_str);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IndexEvaluator1* var_evaluator, IntValueStrategy val_str);
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IntVarStrategy var_str, IndexEvaluator2* val_eval);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IntVarStrategy var_str, IndexEvaluator2* val_eval);
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IndexEvaluator1* var_evaluator, IndexEvaluator2* val_eval);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IndexEvaluator1* var_evaluator, IndexEvaluator2* val_eval);
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IntVarStrategy var_str, IndexEvaluator2* val_eval, IndexEvaluator1* tie_breaker);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IntVarStrategy var_str, IndexEvaluator2* val_eval, IndexEvaluator1* tie_breaker);
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IndexEvaluator1* var_evaluator, IndexEvaluator2* val_eval, IndexEvaluator1* tie_breaker);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IndexEvaluator1* var_evaluator, IndexEvaluator2* val_eval, IndexEvaluator1* tie_breaker);

Shortcuts for small arrays.

DecisionBuilder* MakePhase(IntVar* const v0, IntVarStrategy var_str, IntValueStrategy val_str);
DecisionBuilder* MakePhase(IntVar* const v0, IntVar* const v1, IntVarStrategy var_str, IntValueStrategy val_str);
DecisionBuilder* MakePhase(IntVar* const v0, IntVar* const v1, IntVar* const v2, IntVarStrategy var_str, IntValueStrategy val_str);
DecisionBuilder* MakePhase(IntVar* const v0, IntVar* const v1, IntVar* const v2, IntVar* const v3, IntVarStrategy var_str, IntValueStrategy val_str);

Returns a decision builder which assigns values to variables which minimizes the values returned by the evaluator. The arguments passed to the evaluator callback are the indices of the variables in vars and the values of these variables. Ownership of the callback is passed to the decision builder.
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IndexEvaluator2* evaluator, EvaluatorStrategy str);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IndexEvaluator2* evaluator, EvaluatorStrategy str);

Returns a decision builder which assigns values to variables which minimize the values returned by the evaluator. In case of tie breaks, the second callback is used to choose the best index in the array of equivalent pairs with equivalent evaluations. The arguments passed to the evaluator callback are the indices of the variables in vars and the values of these variables. Ownership of the callback is passed to the decision builder.
DecisionBuilder* MakePhase(const vector<IntVar*>& vars, IndexEvaluator2* evaluator, IndexEvaluator1* tie_breaker, EvaluatorStrategy str);
DecisionBuilder* MakePhase(const IntVar* const* vars, int size, IndexEvaluator2* evaluator, IndexEvaluator1* tie_breaker, EvaluatorStrategy str);

Scheduling phases.
DecisionBuilder* MakePhase(const vector<IntervalVar*>& intervals, IntervalStrategy str);
DecisionBuilder* MakePhase(const vector<Sequence*>& sequences, SequenceStrategy str);
 
Returns a decision builder for which the left-most leaf corresponds to assignment, the rest of the tree being explored using 'db'.
DecisionBuilder* MakeDecisionBuilderFromAssignment(Assignment* const assignment, DecisionBuilder* const db, const IntVar* const* vars, int size);

SolveOnce will collapse a search tree described by a 'db' decision builder, and a set of monitors and wrap it into a single point. If there are no solutions to this nested tree, then SolveOnce will fail. If there is a solution, it will find it and returns NULL.
DecisionBuilder* MakeSolveOnce(DecisionBuilder* const db);
DecisionBuilder* MakeSolveOnce(DecisionBuilder* const db, SearchMonitor* const monitor1);
DecisionBuilder* MakeSolveOnce(DecisionBuilder* const db, SearchMonitor* const monitor1, SearchMonitor* const monitor2);
DecisionBuilder* MakeSolveOnce(DecisionBuilder* const db, SearchMonitor* const monitor1, SearchMonitor* const monitor2, SearchMonitor* const monitor3);
DecisionBuilder* MakeSolveOnce(DecisionBuilder* const db, SearchMonitor* const monitor1, SearchMonitor* const monitor2, SearchMonitor* const monitor3, SearchMonitor* const monitor4);
DecisionBuilder* MakeSolveOnce(DecisionBuilder* const db, const vector<SearchMonitor*>& monitors);

Returns a DecisionBuilder which restores an Assignment (calls void Assignment::Restore())
DecisionBuilder* MakeRestoreAssignment(Assignment* assignment);

Returns a DecisionBuilder which stores an Assignment (calls void Assignment::Store()).
DecisionBuilder* MakeStoreAssignment(Assignment* assignment);

Searching

Top level solve using a decision builder and up to three search monitors, usually one for the objective, one for the limits and one to collect solutions.
bool Solver::Solve(DecisionBuilder* const db, const vector<SearchMonitor*>& monitors);
bool Solver::Solve(DecisionBuilder* const db, SearchMonitor* const * monitors, int size);
bool Solver::Solve(DecisionBuilder* const db);
bool Solver::Solve(DecisionBuilder* const db, SearchMonitor* const m1);
bool Solver::Solve(DecisionBuilder* const db, SearchMonitor* const m1, SearchMonitor* const m2);
bool Solver::Solve(DecisionBuilder* const db, SearchMonitor* const m1, SearchMonitor* const m2, SearchMonitor* const m3);
bool Solver::Solve(DecisionBuilder* const db, SearchMonitor* const m1, SearchMonitor* const m2, SearchMonitor* const m3, SearchMonitor* const m4);

Decomposed top level search. The code should look like 
solver->NewSearch(db);
while (solver->NextSolution()) {
  .. use the current solution
}
solver()->EndSearch();


void Solver::NewSearch(DecisionBuilder* const db, const vector<SearchMonitor*>& monitors);
void Solver::NewSearch(DecisionBuilder* const db, SearchMonitor* const * monitors, int size);
void Solver::NewSearch(DecisionBuilder* const db);
void Solver::NewSearch(DecisionBuilder* const db, SearchMonitor* const m1);
void Solver::NewSearch(DecisionBuilder* const db, SearchMonitor* const m1, SearchMonitor* const m2);
void Solver::NewSearch(DecisionBuilder* const db, SearchMonitor* const m1, SearchMonitor* const m2, SearchMonitor* const m3);
void Solver::NewSearch(DecisionBuilder* const db, SearchMonitor* const m1, SearchMonitor* const m2, SearchMonitor* const m3, SearchMonitor* const m4);

bool Solver::NextSolution();
void Solver::RestartSearch();
void Solver::EndSearch();

Nested solve using a decision builder and up to three search monitors, usually one for the objective, one for the limits and one to collect solutions. The restore parameter indicates if the search should backtrack completely after completion, even in case of success.
bool Solver::NestedSolve(DecisionBuilder* const db, bool restore, const vector<SearchMonitor*>& monitors);
bool Solver::NestedSolve(DecisionBuilder* const db, bool restore, SearchMonitor* const * monitors, int size);
bool Solver::NestedSolve(DecisionBuilder* const db, bool restore);
bool Solver::NestedSolve(DecisionBuilder* const db, bool restore, SearchMonitor* const m1);
bool Solver::NestedSolve(DecisionBuilder* const db, bool restore, SearchMonitor* const m1, SearchMonitor* const m2);
bool Solver::NestedSolve(DecisionBuilder* const db, bool restore, SearchMonitor* const m1, SearchMonitor* const m2, SearchMonitor* const m3);

This method returns the validity of the given assignment against the current model.
bool Solver::CheckAssignment(Assignment* const assignment);
State of the solver.
enum SolverState {
 OUTSIDE_SEARCH,
 IN_SEARCH,
 AFTER_SUCCESS,
 AFTER_FAILURE,
 PROBLEM_INFEASIBLE
};

SolverState Solver::state() const;

Abandon the current branch in the search tree. A backtrack will follow. This should be called from within the search.
void Solver::Fail();

Local Search

Useful Enums

enum LocalSearchOperators { 
TWOOPT, 
OROPT, 
RELOCATE, 
EXCHANGE, 
CROSS, 
MAKEACTIVE, 
MAKEINACTIVE, 
SWAPACTIVE, 
EXTENDEDSWAPACTIVE, 
PATHLNS, 
UNACTIVELNS, 
INCREMENT, 
DECREMENT, 
SIMPLELNS 
}; 

enum EvaluatorLocalSearchOperators { 
LK, 
TSPOPT, 
TSPLNS 
}; 

enum LocalSearchFilterBound { 
GE, 
LE, 
EQ 
}; 

enum LocalSearchOperation { 
SUM, 
PROD, 
MAX, 
MIN 
}; 

Solution Pool

This class is used to manage a pool of solutions. It can transform a single point local search into a multi point local search. 
class SolutionPool : public BaseObject { 
 public: 
  SolutionPool();
  ~SolutionPool();   // This method is called to initialize the solution pool with the assignment from the local search. 
  virtual void Initialize(Assignment* const assignment) = 0; 
  // This method is called when a new solution has been accepted by the local search. 
  virtual void RegisterNewSolution(Assignment* const assignment) = 0; 
  // This method is called when the local search starts a new neighborhood to initialize the default assignment. 
  virtual void GetNextSolution(Assignment* const assignment) = 0; 
  // This method checks if the local solution needs to be updated with an external one. 
  virtual bool SyncNeeded(Assignment* const local_assignment) = 0; 
}; SolutionPool* Solver::MakeDefaultSolutionPool(); 
Local Search Operators

LocalSearchOperator* Solver::MakeOperator(const vector<IntVar*>& vars, LocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const IntVar* const* vars, int size, LocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const vector<IntVar*>& vars, const vector<IntVar*>& secondary_vars, LocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const IntVar* const* vars, const IntVar* const* secondary_vars, int size, LocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const vector<IntVar*>& vars, IndexEvaluator3* evaluator, EvaluatorLocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const IntVar* const* vars, int size, IndexEvaluator3* evaluator, EvaluatorLocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const vector<IntVar*>& vars, const vector<IntVar*>& secondary_vars, IndexEvaluator3* evaluator, EvaluatorLocalSearchOperators op); 
LocalSearchOperator* Solver::MakeOperator(const IntVar* const* vars, const IntVar* const* secondary_vars, int size, IndexEvaluator3* evaluator, EvaluatorLocalSearchOperators op);

Creates a local search operator which concatenates a vector of operators.  Each operator from the vector is called sequentially. By default, when a  neighbor is found the neighborhood exploration restarts from the last active operator (the one which produced the neighbor).  This can be overriden by setting restart to true to force the exploration to start from the first operator in the vector. The default behavior can also be overriden using an evaluation callback to set the order in which the operators are explored (the callback is called in LocalSearchOperator::Start()). The first argument of the callback is the index of the operator which produced the last move, the second argument is the index of the operator to be evaluated. Ownership of the callback is taken by ConcatenateOperators. 
 
Example: 
const int kPriorities = {10, 100, 10, 0}; 
int64 Evaluate(int active_operator, int current_operator) { 
  return kPriorities[current_operator]; 
} 

LocalSearchOperator* concat = solver.ConcatenateOperators(operators, NewPermanentCallback(&Evaluate));

The elements of the vector operators will be sorted by increasing priority and explored in that order (tie-breaks are handled by keeping the relative operator order in the vector). This would result in the following order: operators[3], operators[0], operators[2], operators[1]. 

LocalSearchOperator* Solver::ConcatenateOperators(const vector<LocalSearchOperator*>& ops); 
LocalSearchOperator* Solver::ConcatenateOperators(const vector<LocalSearchOperator*>& ops, bool restart); 
LocalSearchOperator* Solver::ConcatenateOperators(const vector<LocalSearchOperator*>& ops, ResultCallback2<int64, int, int>* evaluator);  Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor().  LocalSearchOperator* Solver::RandomConcatenateOperators(const vector<LocalSearchOperator*>& ops);

Local Search decision builders factories. 

Local search is used to improve a given solution. This initial solution can be specified either by an Assignment or by a DecisionBulder, and the corresponding variables, the initial solution being the first solution found by the DecisionBuilder. 
The LocalSearchPhaseParameters parameter holds the actual definition of the local search phase: 
a local search operator used to explore the neighborhood of the current solution, 
a decision builder to instantiate unbound variables once a neighbor has been defined; in the case of LNS-based operators instantiates fragment variables; search monitors can be added to this sub-search by wrapping the decision builder with MakeSolveOnce. 
a search limit specifying how long local search looks for neighbors before accepting one; the last neighbor is always taken and in the case of a greedy search, this corresponds to the best local neighbor; first-accept (which is the default behavior) can be modeled using a solution found limit of 1, 
a vector of local search filters used to speed up the search by pruning unfeasible neighbors. Metaheuristics can be added by defining specialized search monitors; currently down/up-hill climbing is available through OptimizeVar, as well as Guided Local Search, Tabu Search and Simulated Annealing. 
DecisionBuilder* Solver::MakeLocalSearchPhase(Assignment* assignment, LocalSearchPhaseParameters* parameters); 
DecisionBuilder* Solver::MakeLocalSearchPhase(const vector<IntVar*>& vars, DecisionBuilder* first_solution, LocalSearchPhaseParameters* parameters); 
DecisionBuilder* Solver::MakeLocalSearchPhase(IntVar* const* vars, int size, DecisionBuilder* first_solution, LocalSearchPhaseParameters* parameters); 
Local Search Phase Parameters 

LocalSearchPhaseParameters* Solver::MakeLocalSearchPhaseParameters(LocalSearchOperator* ls_operator, DecisionBuilder* sub_decision_builder); 
LocalSearchPhaseParameters* Solver::MakeLocalSearchPhaseParameters(LocalSearchOperator* ls_operator, DecisionBuilder* sub_decision_builder, SearchLimit* const limit); 
LocalSearchPhaseParameters* Solver::MakeLocalSearchPhaseParameters(LocalSearchOperator* ls_operator, DecisionBuilder* sub_decision_builder, SearchLimit* const limit, const vector<LocalSearchFilter*>& filters); 
LocalSearchPhaseParameters* Solver::MakeLocalSearchPhaseParameters(SolutionPool* const pool, LocalSearchOperator* ls_operator, DecisionBuilder* sub_decision_builder); 
LocalSearchPhaseParameters* Solver::MakeLocalSearchPhaseParameters(SolutionPool* const pool, LocalSearchOperator* ls_operator, DecisionBuilder* sub_decision_builder, SearchLimit* const limit); 
LocalSearchPhaseParameters* Solver::MakeLocalSearchPhaseParameters(SolutionPool* const pool, LocalSearchOperator* ls_operator, DecisionBuilder* sub_decision_builder, SearchLimit* const limit, const vector<LocalSearchFilter*>& filters); 
Local Search Filters 

LocalSearchFilter* Solver::MakeVariableDomainFilter(); 
LocalSearchFilter* Solver::MakeLocalSearchObjectiveFilter(const IntVar* const* vars, int size, IndexEvaluator2* values, const IntVar* const objective, Solver::LocalSearchFilterBound filter_enum, Solver::LocalSearchOperation op_enum); 
LocalSearchFilter* Solver::MakeLocalSearchObjectiveFilter(const vector<IntVar*>& vars, IndexEvaluator2* values, const IntVar* const objective, Solver::LocalSearchFilterBound filter_enum, Solver::LocalSearchOperation op_enum); 
LocalSearchFilter* Solver::MakeLocalSearchObjectiveFilter(const IntVar* const* vars, const IntVar* const* secondary_vars, int size, ResultCallback3<int64, int64, int64, int64>* values, const IntVar* const objective, Solver::LocalSearchFilterBound filter_enum, Solver::LocalSearchOperation op_enum); 

Search Extensions

Assignments

Assignments are used to store solutions or partial solutions of a problem. It is a variable -> domain mapping.

The main class is the Assignment class:

class Assignment : public PropagationBaseObject {
 public:
  explicit Assignment(Solver* const s);
  explicit Assignment(const Assignment* const copy);
  virtual ~Assignment();

  void Clear();
  bool Empty() const;

  int Size() const;
  void Store();
  void Restore();

  void AddObjective(IntVar* const v);
  IntVar* Objective() const;
  bool HasObjective() const;
  int64 ObjectiveMin() const;
  int64 ObjectiveMax() const;
  int64 ObjectiveValue() const;
  bool ObjectiveBound() const;
  void SetObjectiveMin(int64 m);
  void SetObjectiveMax(int64 m);
  void SetObjectiveValue(int64 value);
  void SetObjectiveRange(int64 l, int64 u);

  IntVarElement& Add(IntVar* const v);
  void Add(IntVar* const* vars, int size);
  void Add(const vector<IntVar*>& v);
  // Adds without checking if variable has been previously added.
  IntVarElement& FastAdd(IntVar* const v);
  int64 Min(const IntVar* const v) const;
  int64 Max(const IntVar* const v) const;
  int64 Value(const IntVar* const v) const;
  bool Bound(const IntVar* const v) const;
  void SetMin(const IntVar* const v, int64 m);
  void SetMax(const IntVar* const v, int64 m);
  void SetRange(const IntVar* const v, int64 l, int64 u);
  void SetValue(const IntVar* const v, int64 value);

  IntervalVarElement& Add(IntervalVar* const v);
  void Add(IntervalVar* const * vars, int size);
  void Add(const vector<IntervalVar*>& vars);
  // Adds without checking if variable has been previously added.
  IntervalVarElement& FastAdd(IntervalVar* const v);
  int64 StartMin(const IntervalVar* const v) const;
  int64 StartMax(const IntervalVar* const v) const;
  int64 DurationMin(const IntervalVar* const v) const;
  int64 DurationMax(const IntervalVar* const v) const;
  int64 EndMin(const IntervalVar* const v) const;
  int64 EndMax(const IntervalVar* const v) const;
  int64 PerformedMin(const IntervalVar* const v) const;
  int64 PerformedMax(const IntervalVar* const v) const;
  void SetStartMin(const IntervalVar* const v, int64 m);
  void SetStartMax(const IntervalVar* const v, int64 m);
  void SetStartRange(const IntervalVar* const v, int64 mi, int64 ma);
  void SetStartValue(const IntervalVar* const v, int64 value);
  void SetDurationMin(const IntervalVar* const v, int64 m);
  void SetDurationMax(const IntervalVar* const v, int64 m);
  void SetDurationRange(const IntervalVar* const v, int64 mi, int64 ma);
  void SetDurationValue(const IntervalVar* const v, int64 value);
  void SetEndMin(const IntervalVar* const v, int64 m);
  void SetEndMax(const IntervalVar* const v, int64 m);
  void SetEndRange(const IntervalVar* const v, int64 mi, int64 ma);
  void SetEndValue(const IntervalVar* const v, int64 value);
  void SetPerformedMin(const IntervalVar* const v, int64 m);
  void SetPerformedMax(const IntervalVar* const v, int64 m);
  void SetPerformedRange(const IntervalVar* const v, int64 mi, int64 ma);
  void SetPerformedValue(const IntervalVar* const v, int64 value);

  void Activate(const IntVar* const v);
  void Deactivate(const IntVar* const v);
  bool Activated(const IntVar* const v) const;
  void Activate(const IntervalVar* const v);
  void Deactivate(const IntervalVar* const v);
  bool Activated(const IntervalVar* const v) const;

  void ActivateObjective();
  void DeactivateObjective();
  bool ActivatedObjective() const;

  virtual string DebugString() const;

  bool Contains(const IntVar* const var) const;
  bool Contains(const IntervalVar* const var) const;

  // Copies the intersection of the 2 assignments to the current assignment.
  void Copy(const Assignment* assignment);
};


This method creates an empty assignment.
Assignment* Solver::MakeAssignment();
This method creates an assignnment which is a copy of 'a'.

Assignment* Solver::MakeAssignment(const Assignment* const a);
Search Monitors

class SearchMonitor : public BaseObject {
 public:
  explicit SearchMonitor(Solver* const s) : solver_(s);
  virtual ~SearchMonitor();
  // Beginning of the search.
  virtual void EnterSearch();
  // Restart the search.
  virtual void RestartSearch();
  // End of the search.
  virtual void ExitSearch(); 
  // Before calling DecisionBuilder::Next
  virtual void BeginNextDecision(DecisionBuilder* const b);
  // After calling DecisionBuilder::Next, along with the returned decision.
  virtual void EndNextDecision(DecisionBuilder* const b, Decision* const d);
  // Before applying the decision
  virtual void ApplyDecision(Decision* const d);
  // Before refuting the Decision
  virtual void RefuteDecision(Decision* const d);
  // Just when the failure occurs.
  virtual void BeginFail();
  // After completing the backtrack.
  virtual void EndFail();
  // Before the initial propagation.
  virtual void BeginInitialPropagation();
  // After the initial propagation.
  virtual void EndInitialPropagation();
  // This method is called when a solution is found. If 'true' is returned, this last solution is discarded and the search proceeds with the next one.
  virtual bool RejectSolution();
  // When the search tree is finished.
  virtual void NoMoreSolutions();
  // When a local optimum is reached. If 'true' is returned, the last solution is discarded and the search proceeds with the next one.
  virtual bool LocalOptimum();
  //
  virtual bool AcceptDelta(Assignment* delta, Assignment* deltadelta);
  // After accepting a neighbor during local search.
  virtual void AcceptNeighbor();
  // Returns the solver passed to the constructor.
  Solver* solver() const { return solver_; }
  // Tells the solver to kill the current search.
  void FinishCurrentSearch();
  // Tells the solver to restart the current search.
  void RestartCurrentSearch();
  // Periodic call to check limits in long running methods.
  virtual void PeriodicCheck();
};
Solution Collectors

This class is the root class of all solution collector. It implements a basic query API to be used independently from the collector used.

class SolutionCollector : public SearchMonitor {
 public:
  SolutionCollector(Solver* const s, const Assignment* a);
  virtual ~SolutionCollector();
  // Beginning of the search.
  virtual void EnterSearch();
  // Returns how many solutions were stored during the search.
  int solution_count() const;
  // Returns the nth solution.
  Assignment* solution(int n) const;
  // Returns the wall time in ms for the nth solution.
  int64 wall_time(int n) const;
  // Returns the number of branches when the nth solution was found.
  int64 branches(int n) const;
  // Returns the number of failures encountered at the time of the nth solution.
  int64 failures(int n) const;
  // Returns the objective value of the nth solution.
  int64 objective_value(int n) const;
};


Collects the first solution of the search. 
SolutionCollector* Solver::MakeFirstSolutionCollector(const Assignment* a);


Collects the last solution of the search. 
SolutionCollector* Solver::MakeLastSolutionCollector(const Assignment* a);


Collect the solution corresponding to the optimal value of the objective of 'a'; if 'a' does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found). 
SolutionCollector* Solver::MakeBestValueSolutionCollector(const Assignment* a, bool maximize);


Collects all solutions of the search. 
SolutionCollector* Solver::MakeAllSolutionCollector(const Assignment* a);
Objective

Objective management is based on the OptimizeVar class, itself a subclass of search monitors.

class OptimizeVar : public SearchMonitor {
 public:
  OptimizeVar(Solver* const s, bool maximize, IntVar* a, int64 step);
  virtual ~OptimizeVar();
  // Returns the best value found during search.
  int64 best() const { return best_; }
  // Returns the variable passed in the ctor.
  IntVar* Var() const { return var_; }
};


Creates a minimization objective. 
OptimizeVar* Solver::MakeMinimize(IntVar* const v, int64 step);

Creates a maximization objective. 
OptimizeVar* Solver::MakeMaximize(IntVar* const v, int64 step);

Creates a objective with a given sense (true = maximization). 
OptimizeVar* Solver::MakeOptimize(bool maximize, IntVar* const v, int64 step);

Meta-heuristics

Meta-heuristics are search monitors which try to get the search out of local optima. 

Creates a Tabu Search monitor. In the context of local search the behavior is similar to MakeOptimize(), creating an objective in a given sense. The behavior differs once a local optimum is reached: thereafter solutions which degrade the value of the objective are allowed if they are not "tabu". A solution is "tabu" if it doesn't respect the following rules:
improving the best solution found so far
variables in the "keep" list must keep their value, variables in the "forbid" list must not take the value they have in the list. Variables with new values enter the tabu lists after each new solution found and leave the lists after a given number of iterations (called tenure). Only the variables passed to the method can enter the lists. The tabu criterion is softened by the tabu factor which gives the number of "tabu" violations which is tolerated; a factor of 1 means no violations allowed, a factor of 0 means all violations allowed. 
SearchMonitor* Solver::MakeTabuSearch(bool maximize, IntVar* const v, int64 step, const vector<IntVar*>& vars, int64 keep_tenure, int64 forbid_tenure, double tabu_factor); 
SearchMonitor* Solver::MakeTabuSearch(bool maximize, IntVar* const v, int64 step, const IntVar* const* vars, int size, int64 keep_tenure, int64 forbid_tenure, double tabu_factor); 

Creates a Simulated Annealing monitor. 
SearchMonitor* Solver::MakeSimulatedAnnealing(bool maximize, IntVar* const v, int64 step, int64 initial_temperature); 

Creates a Guided Local Search monitor. (Description here: http://en.wikipedia.org/wiki/Guided_Local_Search) 
SearchMonitor* Solver::MakeGuidedLocalSearch(bool maximize, IntVar* const objective, IndexEvaluator2* objective_function, int64 step, const vector<IntVar*>& vars, double penalty_factor); 
SearchMonitor* MakeGuidedLocalSearch(bool maximize, IntVar* const objective, IndexEvaluator2* objective_function, int64 step, const IntVar* const* vars, int size, double penalty_factor); 
SearchMonitor* MakeGuidedLocalSearch(bool maximize, IntVar* const objective, IndexEvaluator3* objective_function, int64 step, const vector<IntVar*>& vars, const vector<IntVar*> secondary_vars, double penalty_factor); 
SearchMonitor* MakeGuidedLocalSearch(bool maximize, IntVar* const objective, IndexEvaluator3* objective_function, int64 step, const IntVar* const* vars, const IntVar* const* secondary_vars, int size, double penalty_factor);
Restart Search

This search monitor will restart the search periodically. At the iteration n, it will restart after scale_factor * Luby(n) failures where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...). 
SearchMonitor* Solver::MakeLubyRestart(int scale_factor); 

This search monitor will restart the search periodically after 'frequency' failures. 
SearchMonitor* Solver::MakeConstantRestart(int frequency); 
Search Limit

Base class of all search limits
class SearchLimit : public SearchMonitor {
 public:
  explicit SearchLimit(Solver* const s);
  virtual ~SearchLimit();
  // Returns true if the limit has been crossed.
  bool crossed() const;
  // This method is called to check the status of the limit. A return value of true indicates that we have indeed crossed the limit. In that case, this method will not be called again and the remaining search will be discarded.
  virtual bool Check() = 0;
  // This method is called when the search limit is initialized.
  virtual void Init() = 0;
  // Copy a limit. Warning: leads to a direct (no check) downcasting of 'limit' so one needs to be sure both SearchLimits are of the same type.
  virtual void Copy(const SearchLimit* const limit) = 0;
  // Allocates a clone of the limit 
  virtual SearchLimit* MakeClone() const = 0;
};

Limit the search with the 'time', 'branches', 'failures' and 'solutions' limits.
SearchLimit* Solver::MakeLimit(int64 time, int64 branches, int64 failures, int64 solutions); 

Version reducing calls to wall timer by estimating number of remaining calls.
SearchLimit* Solver::MakeLimit(int64 time, int64 branches, int64 failures, int64 solutions, bool smart_time_check);

Update a limit with new bounds.
void Solver::UpdateLimits(int64 time, int64 branches, int64 failures, int64 solutions, SearchLimit* limit); 

Returns 'time' limit of search limit 
int64 Solver::GetTime(SearchLimit* limit); 

Callback-based search limit. Search stops when limiter returns true; if this happens at a leaf the corresponding solution will be rejected. 
SearchLimit* Solver::MakeCustomLimit(ResultCallback<bool>* limiter);

Search Log

Creates a search monitor that will display a periodic search log on LOG(INFO). 
SearchMonitor* Solver::MakeSearchLog(int period); 

Creates a search monitor that will display a periodic search log on LOG(INFO). At each solution, this monitor will also display the objective value. 
SearchMonitor* Solver::MakeSearchLog(int period, IntVar* const objective); 

Create a search monitor that will call the display callback at each solution. 
SearchMonitor* Solver::MakeSearchLog(int period, ResultCallback<string>* display_callback);
 
Creates a search monitor that will call the display callback and display the objective value at each solution. 
SearchMonitor* Solver::MakeSearchLog(int period, IntVar* objective, ResultCallback<string>* display_callback);
Search Trace

Create a search monitor that will trace precisely the behavior of the search. Use this only for low level debugging. 
SearchMonitor* Solver::MakeSearchTrace(const string& prefix);

Branch Selector
Sets the given branch selector on the current active search. 
enum DecisionModification {
  NO_CHANGE,
  KEEP_LEFT,
  KEEP_RIGHT,
  KILL_BOTH,
  SWITCH_BRANCHES
};
void Solver::SetBranchSelector(ResultCallback1<Solver::DecisionModification, Solver*>* const bs); 

Creates a decision builder that will set the branch selector. 
DecisionBuilder* Solver::MakeApplyBranchSelector(ResultCallback1<Solver::DecisionModification, Solver*>* const bs); 

Symmetry Breaking

SearchMonitor* Solver::MakeSymmetryManager(const vector<SymmetryBreaker*>& visitors); 
SearchMonitor* Solver::MakeSymmetryManager(SymmetryBreaker* const * visitors, int size); 
SearchMonitor* Solver::MakeSymmetryManager(SymmetryBreaker* const v1); 
SearchMonitor* Solver::MakeSymmetryManager(SymmetryBreaker* const v1, SymmetryBreaker* const v2); 
SearchMonitor* Solver::MakeSymmetryManager(SymmetryBreaker* const v1, SymmetryBreaker* const v2, SymmetryBreaker* const v3); 
SearchMonitor* Solver::MakeSymmetryManager(SymmetryBreaker* const v1, SymmetryBreaker* const v2, SymmetryBreaker* const v3, SymmetryBreaker* const v4); 

Solver Statuses and Misc Methods 

Current memory usage in bytes.
static int64 Solver::MemoryUsage(); 

Wall time in ms since the creation of the solver. 
int64 Solver::wall_time() const; 

Number of branches explored since the creation of the solver. 
int64 Solver::branches() const;

Number of solutions found since the start of the search. 
int64 Solver::solutions() const; 

Number of demons executed during search for a given priority. 
int64 Solver::demon_runs(DemonPriority p) const;

Number of failures encountered since the creation of the solver. 
int64 Solver::failures() const; 

Number of neighbors created 
int64 Solver::neighbors() const;

Number of filtered neighbors (neighbors accepted by filters) 
int64 filtered_neighbors() const;

Number of accepted neighbors 
int64 Solver::accepted_neighbors() const;

The stamp indicates how many moves (up or down) in the search tree we have performed.  It is useful to detect if we need to update same lazy structures. 
uint64 Solver::stamp() const; 

The fail_stamp() is incremented after each backtrack. 
uint64 Solver::fail_stamp() const; 

Gets the search depth of the current active search. Returns -1 in case there are no active search opened. 
int Solver::SearchDepth() const; 

Gets the search left depth of the current active search. Returns -1 in case there are no active search opened. 
int Solver::SearchLeftDepth() const; 

Gets the number of nested searches. It returns 0 outside search, 1 during the top level search, 2 if one level of NestedSolve() is used, and more if more solves are nested. 
int Solver::SolveDepth() const; 

Callback typedefs 
typedef ResultCallback1<int64, int64> IndexEvaluator1; 
typedef ResultCallback2<int64, int64, int64> IndexEvaluator2; 
typedef ResultCallback3<int64, int64, int64, int64> IndexEvaluator3; 

Pretty Print Method
string Solver::DebugString() const; 

Returns a random value between 0 and 'size' - 1; 
int64 Solver::Rand64(int64 size); 

Returns a random value between 0 and 'size' - 1; 
int32 Solver::Rand32(int32 size); 

Reseed the solver random generator. 
void Solver::ReSeed(int32 seed); 

Add a fail hook, that is an action that will be called after each failure. 
void Solver::AddFailHook(Action* a); 

This functions returns true wether the current search has been created using a Solve() call instead of a NewSearch 0ne. It returns false if the solver is not is search at all. 
bool Solver::CurrentlyInSolve() const; 

This method counts the number of constraints that have been added to the solver before the search, 
int Solver::constraints() const;

This method returns 0. It is useful when 0 can be cast either as a pointer or as a integer value and thus lead to an ambiguous function call. 
inline int64 Zero() { return 0LL; }