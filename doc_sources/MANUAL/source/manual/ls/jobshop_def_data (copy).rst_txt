..  _jobshop_def:

The job-shop problem, benchmark data and a first model 
--------------------------------------------------------

We describe the job-shop problem, a first model and the benchmark data. The job-shop problem belongs to the 
intractable problems (:math:`\in` NP). Only few very special cases can be solved in 
polynomial time (see [Garey1976]_ and [Kis2002]_).
    
..  [Garey1976] Garey, M. R., Johnson, D. S. and Sethi, R., *The complexity of flowshop and jobshop scheduling*,
    Mathematics of Operations Research, volume 1, pp 117-129, 1976.

..  [Kis2002] Kis, T., *On the complexity of non-preemptive shop scheduling with two jobs*, Computing, volume 69, nbr 1, pp 37-49, 
    2002.

Description of the problem 
^^^^^^^^^^^^^^^^^^^^^^^^^^

In the classical job-shop problem there are :math:`n` jobs that must be processed on :math:`m` machines. 
Each job consists of a sequence of different tasks [#tasks_operations]_. Each task needs to be processed during an 
uninterrupted period of time on a given machine.

..  [#tasks_operations] Tasks are also called *operations*.

We use [#job_shop_pedagogical_notation]_ :math:`a_{ij}` to denote the :math:`i^\textrm{th}` task of job :math:`j`. 

Given a  set :math:`J` of jobs, a set :math:`M` of machines and a set :math:`T` of tasks, we denote 
by :math:`\tau_j` the number of tasks for a given job :math:`j \in J`. To each task :math:`a_{ij}` corresponds 
an ordered pair :math:`(m_{ij}, p_{ij})`: the task :math:`m_{ij}` needs to be processed on machine :math:`m_{ij} \in M` 
for a period of :math:`p_{ij}` units of time.
    
..  [#job_shop_pedagogical_notation] We use a slightly different and we hope easier notation than the ones used by the 
    scheduling community.
    
Here is an example with :math:`m=3` machines and :math:`n=3` jobs. We count jobs, machines and tasks starting from 0.
    
      - job 0 = :math:`[(0,3), (1,2), (2,2)]`
      - job 1 = :math:`[(0,2), (2,1), (1,4)]`
      - job 2 = :math:`[(1,4), (2,3)]`

For instance, job 2 consists of  :math:`\tau_2 = 2` tasks: task :math:`a_{02}` which must be processed on machine :math:`m_{02} = 1` 
during :math:`p_{02} = 4` units of time and task :math:`a_{12}` which must be processed on machine :math:`m_{02} = 2` 
during :math:`p_{02} = 3` units of time.

To have a **job-shop problem**, the tasks must be processed in the order given by the sequence: 
for job 0 this means that task :math:`a_{00}` 
on machine 0 must be processed before task :math:`a_{10}` on machine 1 that itself must be processed before task :math:`a_{20}` 
on machine 2. It is not mandatory but most of the literature and benchmark data are concerned by problems where each job 
is made of :math:`m` tasks and each task in a job must be processed on a different machine, i.e. each job needs to be 
processed exactly once on each machine.
    
We seek a **schedule** (solution) that minimizes the **makespan** (duration) of the whole process. 
    
The *makespan* is the duration between the start of the first task (across all machines) and the completion of the last task 
(again across all machines). The classical notation for the makespan is :math:`C_{\textrm{max}}`.
    
The makespan can be defined as
    
..  math::
    
    C_{\textrm{max}} = \max_{t_{ij}} \{t_{ij} + p_{ij}\}
        
or equivalently as the maximum time needed among all jobs to be completely processed. Recall that :math:`\tau_j`
denotes the number of tasks for job :math:`j` and that we count starting from 0. :math:`t_{\tau_j-1,j}` denotes thus
the starting time of the last task of job :math:`j` and we have
    
..  math::
    
    C_{\textrm{max}} = \max_{t_{\tau_j-1,j}} \{t_{\tau_j-1,j} + p_{\tau_j-1,j}\}
    
Let's try to find a schedule for our example. Suppose you want to favour job 1 because not only did you see that
it is the longest job to process but its last task takes 4 units of time. Here is the *Gantt chart* of a possible
schedule:
    
..  only:: html 
    
    .. image:: images/schedule1.*
       :width: 400pt
       :align: center

..  only:: latex
    
    .. image:: images/schedule1.*
       :width: 300pt
       :align: center
    
This is a feasible schedule since tasks within every job are processed one after the other in the right sequence. The makespan
is 12 units of time. Can we do better? Focusing on one job is probably not the best strategy. Here is an optimal solution:
    
..  only:: html 
    
    .. image:: images/schedule2.*
       :width: 400pt
       :align: center

..  only:: latex
    
    .. image:: images/schedule2.*
       :width: 300pt
       :align: center
    
Its makespan is 11 units of time.
    
How can we simply describe a schedule? Let us define :math:`t_{ij}` as the starting time of task :math:`a_{ij}`. A feasible 
*schedule* will then be a set [#set_and_a_correspondence_rule]_ of non negative integers :math:`\{t_{ij}\}` 
such that the definition of a job-shop problem is respected.
If we only consider schedules where all tasks are completely left shifted on the Gantt chart [#left_shifted_schedules]_, we can define 
a feasible schedule by giving the sequence of jobs processed on each machine.
    
..  [#left_shifted_schedules] A rigorous definition of *schedules where all tasks are completely left shifted on the Gantt chart*
    is beyond the scope of this manual. In scheduling jargon, such schedules are called *semi-active* schedules.

..  [#set_and_a_correspondence_rule] And a correspondence rule between those integers and the tasks.

The first schedule can be described by:
    
      - Machine 0: job 1, job 0
      - Machine 1: job 2, job 1, job 0
      - Machine 2: job 1, job 2, job 0

and the second optimal one by
    
      - Machine 0: job 0, job 1
      - Machine 1: job 2, job 0, job 1
      - Machine 2: job 1, job 0, job 2

The Gantt chart offers a nice visualization of schedules but it doesn't really give any insight into the 
problem [#except_if_you_see_disjunctive_graphs]_. 
The disjunctive graph  
allows a better understanding of the structure of the problem.
    
..  [#except_if_you_see_disjunctive_graphs] Except if you see the disjunctive graph in the Gantt chart!
    

    
The disjunctive graph
^^^^^^^^^^^^^^^^^^^^^^^^^^^

..  raw:: latex

    Figure~\ref{manual/ls/jobshop_def_data:disjunctive-graph1} represents the \emph{disjunctive graph} of 
    our example.


..  only:: html

    The Figure :ref:`disjunctive_graph1` 
    represents the *disjunctive graph* of 
    our example.

..  _disjunctive_graph1:

..  figure:: images/disjunctive_graph1.*
    :alt: A disjunctive graph.
    :align: center
    :width: 400pt
        
    A disjunctive graph.

..  only:: html

    The graph is :math:`G = (V, C \cup D)` where
    
          :math:`V` is the set of vertices corresponding to the tasks. Two fictive vertices :math:`s` and :math:`t` are added to
            represent the start and end times. Each vertex has a weight corresponding to the processing time of the task it represents.
            Vertices :math:`s` and :math:`t` have weight 0.
      
          :math:`C` is a set of *conjunctive arcs* between the :math:`i^{\textrm{th}}` and :math:`(i+1)^{\textrm{th}}` tasks of a job.
            We also add conjunctive arcs from :math:`s` to the first task of every job and from the last task of every job to :math:`t`.
            These arcs are plain in the Figure :ref:`disjunctive_graph1`.

          :math:`D` is a set of *disjunctive arcs* between tasks to be processed on the same machine.
            These arcs are dotted or dashed in the Figure :ref:`disjunctive_graph1`.


..  raw:: latex

    The graph is $G = (V, C \cup D)$ where

    \begin{itemize}
        
        \item $V$ is  the set of vertices corresponding to the tasks. Two fictive vertices $s$ and $t$ are added to
         represent the start and end times. Each vertex has a weight corresponding to the processing time of the task it represents.
         Vertices $s$ and $t$ have weight 0.
    
        \item $C$ are the \emph{conjunctive arcs} between the $i^{\textrm{th}}$ and $(i+1)^{\textrm{th}}$ tasks of a job.
          We also add conjunctive arcs from $s$ to the first task of every job and from the last task of every job to $t$.
          These arcs are plain in Figure~\ref{manual/ls/jobshop_def_data:disjunctive-graph1}.
          
        \item $D$ are the \emph{disjunctive arcs} between task to be processed on the same machine.
            These arcs are dotted or dashed in Figure~\ref{manual/ls/jobshop_def_data:disjunctive-graph1}.
    \end{itemize}

To determine a schedule we have to define an ordering of all tasks processed on each machine. This can be done by orienting 
all dotted or dashed edges such that each clique corresponding to a machine becomes acyclic [#acyclic_machine_clique]_.
    
    
..  [#acyclic_machine_clique] An acyclic graph is a graph without cycle. It can be shown that a complete directed acyclic graph induces 
    a total order on its vertices, i.e. a complete directed acyclic graph lets you order all its vertices unequivocally.
          
Our first schedule is represented in the next Figure.
    
..  only:: html 
    
    .. image:: images/disjunctive_graph2.*
       :width: 400pt
       :align: center

..  only:: latex
    
    .. image:: images/disjunctive_graph2.*
       :width: 300pt
       :align: center

We also want to avoid cycles between disjunctive and conjunctive arcs because they lead to infeasible schedules.
A feasible schedule is represented by a directed acyclic disjunctive graph. In fact, the opposite is also true. A complete orientation 
of the edges in :math:`D` defines a feasible schedule if and only if the resulting directed disjunctive graph is acyclic.
    
The makespan is given by the longest weighted path from :math:`s` to :math:`t`. This path - thickened in the next Figure -
is called the *critical path*.
    
..  only:: html 
    
    .. image:: images/disjunctive_graph3.*
       :width: 400pt
       :align: center

..  only:: latex
    
    .. image:: images/disjunctive_graph3.*
       :width: 300pt
       :align: center

Its length is :math:`0+4+4+2+2+0=12`.

We can now define the job-shop problem as a graph problem: find a complete 
orientation of a disjunctive graph such that the resulting directed graph is acyclic and the longest weighted path
from :math:`s` to :math:`t` is minimized. We will use this representation of the problem to design our first model.


A first model: the disjunctive programming formulation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This first model is a straightforward translation of the definition of a job-shop problem and
its disjunctive graph reprensentation. You can find the code in 
the file :file:`jobshop_wrong.cc`. As the filename suggests, this is NOT the way to model a job-shop problem when 
using Constraint Programming. However, this first 
model will help us better understand the job-shop problem. Later in this chapter, we will 
use ``IntervalVar``\s, ``SequenceVar``\s and special constraints better suited to handle scheduling problems.
    
We again rely on the :ref:`three_stages`. What are the decision **variables**? 
We use the variables :math:`t_{ij}` to store 
the starting time of task :math:`i` of job :math:`j`. We could use two fictive variables corresponding to the fictive 
vertices :math:`s` and :math:`t` but this is not necessary.
    
To simplify the notation, we will use the notation :math:`t_k` where :math:`k` denotes a vertex (a task)
of the disjunctive graph. We use the same simplified notation for the processing times (:math:`p`) and the machine ids (:math:`m`).
    
What are the **constraints**? In the disjunctive graph, we have two kind of edges to model a feasible schedule:
    
      * conjunctive arcs modelling the order in which each task of a job has to be processed:
        
        ..  math:: 
        
            \forall (k,j) \in C (k \neq s, l \neq t):\\
            
            t_k + p_k \leqslant t_l
            
        These constraints are called *conjunctive constraints*.
        
      * disjunctive edges modelling the order in which tasks have to be processed on a single machine:
      
        ..  math::
        
            \forall (k,l) \in D: m_k = m_l\\
            
            t_k + p_k \leqslant t_l \vee t_l + p_l \leqslant t_k
            
        These constraints are called *disjunctive constraints*. They forbid 
        cycles in a clique corresponding to a machine [#cycle_and_disjunctive_constraint]_.
        
        ..  [#cycle_and_disjunctive_constraint] Consider the following situation
        
            ..  only:: html 
        
                .. image:: images/no_cycle.*
                   :width: 100pt
                   :align: center

            ..  only:: latex
                
                .. image:: images/no_cycle.*
                   :width: 70pt
                    
            We have :math:`t_1 + p_1 \leqslant t_2`, :math:`t_2 + p_2 \leqslant t_3` and :math:`t_3 + p_3 \leqslant t_1`. Add 
            these three inequalities and you obtain :math:`p_1 + p_2 + p_3 \leqslant 0`. This is impossible if one of the 
            :math:`p_i` is greater than 0.
        
What is the **objective function**? The objective function (the makespan) :math:`C_{\textrm{max}}` doesn't 
correspond to a variable of the model. We 
have to construct its value. Because we minimize the makespan, we can use
a little trick.  Let :math:`S` be the set of all end tasks of all jobs. In our example, 
:math:`S = \{a_{20}(2,2), a_{21}(1,4), a_{12}(2,3)\}`. The makespan must be greater than the overall time it takes to process these
tasks:
    
..  math::
    
    \forall k \in S:\\
        
    C_{\textrm{max}} \geqslant t_k + p_k.
    
Here is the model [#jobshop_model_exact]_:
    
..  math::
    
    \begin{array}{lcl}
    \min_{t_k}   & C_{\textrm{max}} & \\
    \textrm{s.t.:} &  & \\
    & C_{\textrm{max}} \geqslant t_k + p_k & \forall \, k \in S\\
    & t_k + p_k \leqslant t_l & \forall \, (k,l) \in C\\
    & t_k + p_k \leqslant t_l \vee t_l + p_l \leqslant t_k & \forall \, (k,l) \in D: m_k = m_l\\
    & t_k \geqslant 0 & \forall \, k \in V \setminus \{s,t\}
    \end{array}
    
..  [#jobshop_model_exact] It is not obvious that this model produces optimal solution that are feasible schedules but it can 
    be shown that it does.
    
We will implement and solve this model in the next section but first we need to read and process the data representing 
instances of job-shop problems.
    
The data and file formats
^^^^^^^^^^^^^^^^^^^^^^^^^^

..  only:: draft

    To collect the data, we use two different file formats: **JSSP** and professor **Taillard's instances format**.
    In the directory :file:`data/jobshop`, you can find data files for the job-shop problem.
    The file :file:`jobshop.h` lets you read both formats and store the data into a ``JobshopData`` class we will use 
    throughout this chapter.


JSSP format 
"""""""""""""

..  only:: draft

    *JSSP* stands for *Job Shop Scheduling Problem*. Let's consider the beginning of file :file:`abz9`:
    
    ..  code-block:: text
    
        +++++++++++++++++++++++++++++

        instance abz9

        +++++++++++++++++++++++++++++
        Adams, Balas, and Zawack 15 x 20 instance (Table 1, instance 9)
        20 15
         6 14  5 21  8 13  4 11  1 11 14 35 13 20 11 17 10 18 12 11  ...
         1 35  5 31  0 13  3 26  6 14  9 17  7 38 12 20 10 19 13 12  ...
         0 30  4 35  2 40 10 35  6 30 14 23  8 29 13 37  7 38  3 40  ...
         ...


    The first line of real data is 
    
    ..  code-block:: text
    
        20 15
        
    This instance has 20 jobs to process on 15 machines. Each job is composed of exactly 15 tasks.
    
    Each job corresponds to a line:
    
    ..  code-block:: text
    
        6 14  5 21  8 13  4 11  1 11 14 35 13 20 11 17 10 18 12 11  ...
    
    Each pair :math:`(m_{ij}, p_{ij})` corresponds to a task. 
    For this first job, the first task needs 14 units of time on machine 6, the second task needs 21 units of time
    on machine 5 and so on.
    
    As is often the case, 
    there is a one to one correspondence between the tasks and the machines.
    
    
Taillard's instances format
""""""""""""""""""""""""""""

..  only:: draft

    Let's consider the beginning of file :file:`20_5_01_ta001.txt`:
    
    ..  code-block:: text
    
        20
        5
        873654221
        0
        468
        54 79 16 66 58 
        1
        325
        83 3 89 58 56 
        2
        923
        15 11 49 31 20 
        3
        513
        71 99 15 68 85 
        ...
        
    This format is made for *flow-shop problems* and not job-shop problems. The two first lines indicate that this instance 
    has 20 jobs to be processed on 5 machines. The next line (873654221) is a random seed number. The jobs are numbered from 
    0 to 19. The data for the first job are:
    
    ..  code-block:: text
    
        0
        468
        54 79 16 66 58 
    
    0 is the number of the first job. The next number is not important for the job-shop problem. The last line contains 
    numbers corresponding to processing times. We use the trick to assign these times to machines 0, 1, 2 and so on. So job 0 is 
    actually
    
    ..  math::
    
        [(0,54), (1,79), (2,16), (3,66), (4,58)]
    
    You can find all you ever wanted to know and more about this format in [Taillard1993]_.
    
..  [Taillard1993] Taillard, E., 1993. *Benchmarks for basic scheduling problems*, 
    European Journal of Operational Research, Elsevier, vol. 64(2), pages 278-285, January.

``JobshopData``
""""""""""""""""""

..  only:: draft

    The ``JobshopData`` class is a simple container for job-shop instances. It is defined in the file :file:`jobshop.h`.
    Basically, it wraps an ``std::vector<std::vector<Task> >`` container where ``Task`` is a ``struct`` defined as follows:
    
    ..  code-block:: c++
    
        struct Task {
          Task(int j, int m, int d) : job_id(j), machine_id(m), duration(d) 
          {}
          int job_id;
          int machine_id;
          int duration;
        };

    Most part of the ``JobshopData`` class is devoted to the reading of both file formats.
    
    The public methods are
    
      * ``void Load(const std::string& filename)``: parses and loads the tasks for each job. We use a ``FileLineReader`` (declared in 
        :file:`base/filelinereader.h`) to parse a text file:
        
        ..  code-block:: c++
        
            void Load(const string& filename) {
              FileLineReader reader(filename.c_str());
              reader.set_line_callback(NewPermanentCallback(
                  this,
                  &JobShopData::ProcessNewLine));
              reader.Reload();
              if (!reader.loaded_successfully()) {
                LOG(ERROR) << "Could not open jobshop file";
              }
            } 
            
        ``void ProcessNewLine(char* const line)`` is a callback that parses one line at a time.
        It is triggered by the ``Reload()`` method of the ``FileLineReader``.
        
      * the *getters*:
      
        - ``machine_count()``: number of machines;
        - ``job_count()``: number of jobs;
        - ``name()``: instance name;
        - ``horizon()``: the sum of all durations (and a trivial upper bound on the makespan).
        
      * ``const std::vector<Task>& TasksOfJob(int job_id) const``: returns a reference to the corresponding ``std::vector<Task>`` of tasks.
        



..  raw:: html
    
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

